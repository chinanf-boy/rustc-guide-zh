# 方法查找

由于许多因素的交互作用，方法查找可能相当复杂，例如自我类型、自动删除、特征查找等。此文件提供了过程的概述。更详细的注释当然在代码本身中。

考虑方法查找的一种方法是转换形式的表达式：

```rust,ignore
receiver.method(...)
```

变成更明确的[超滤膜]形式：

```rust,ignore
Trait::method(ADJ(receiver), ...) // for a trait call
ReceiverType::method(ADJ(receiver), ...) // for an inherent method call
```

在这里`ADJ`是一种调整，通常是一系列自动删除，然后可能是一个自动删除（例如，`&**receiver`）然而，我们有时会在这一过程中进行其他调整和胁迫，特别是不施胶（例如，从`[T; n]`到`[T]`）

方法查找分为两个主要阶段：

1.  探测（探测）[`probe.rs`][probe]）探测阶段是我们决定调用什么方法以及如何调整接收器的时候。
2.  确认（确认）[`confirm.rs`][confirm]）。确认阶段“应用”这个选择，更新副表，统一类型变量，或者做一些有副作用的事情。

这种划分的一个原因是更易于缓存。探针相位产生“拾取”（`probe::Pick`，设计为可跨方法调用站点缓存。因此，它不包括推理变量或其他信息。

[ufcs]: https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md

[probe]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/probe/

[confirm]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/confirm/

## 探头相位

### 步骤

探测阶段要做的第一件事是创建一系列*步骤*.这是通过逐步取消对接收器类型的引用，直到它不能再被取消引用，以及应用可选的“取消大小”步骤来完成的。所以如果接收器有类型`Rc<Box<[T; 3]>>`，这可能会产生：

```rust,ignore
Rc<Box<[T; 3]>>
Box<[T; 3]>
[T; 3]
[T]
```

### 候选程序集

然后我们沿着这些步骤搜索以创建*候选人*.A`Candidate`可能是正在调用的方法的方法项。对于每个候选者，我们将推导一个考虑到显式自我的“转换自我类型”。

候选者分为两类，固有的和扩展的。

**固有候选人**是从接收器本身的类型派生的。所以，如果你有一个名义类型的接收器`Foo`（例如，结构），在类似impl的`impl Foo`是固有的方法。不需要导入任何内容来使用固有方法，它们与类型本身关联（请注意，固有的impl只能在与类型本身相同的模块中定义）。

Fixme：固有的候选者并不总是从IMPL派生的。如果您有一个特征对象，例如类型的值`Box<ToString>`，然后是特征方法（`to_string()`（在本例中）与之有内在联系。另一种情况是类型参数，在这种情况下，它们的边界方法是固有的。然而，这部分规则可能会发生变化：当DST的“为特征实现特征”完成时，特征对象调度可以被纳入特征匹配，类型参数行为应该根据WHERE子句重新考虑。

托多：这个定影器还准确吗？

**候选扩展名**源自进口特性。如果我有这种特质`ToString`进口，我打电话来`to_string()`在类型的值上`T`然后我们就去看看是否有`ToString`对于`T`.  这些方法调用称为“扩展方法”。它们可以在任何模块中定义，而不仅仅是定义的模块`T`.  此外，必须导入特性才能调用此类方法。

那么，让我们继续我们的例子。假设我们正在调用一个方法`foo`带着接收器`Rc<Box<[T; 3]>>`还有一个特点`Foo`它的定义是`&self`针对类型`Rc<U>`以及类型的方法`Box`定义`Foo`但与`&mut self`. 那么我们可能有两个候选人：

```text
&Rc<Box<[T; 3]>> from the impl of `Foo` for `Rc<U>` where `U=Box<T; 3]>
&mut Box<[T; 3]>> from the inherent impl on `Box<U>` where `U=[T; 3]`
```

### 候选人搜索

最后，为了实际选择方法，我们将搜索下面的步骤，尝试将接收器类型与候选类型相匹配。在每一步中，我们还考虑自动参考和自动mut参考，看看这是否使任何候选人匹配。我们选择找到匹配的第一步。

在我们的示例中，第一步是`Rc<Box<[T; 3]>>`与任何候选人都不匹配。但是当我们自动生成它时，我们得到了类型`&Rc<Box<[T; 3]>>`哪个匹配。然后，我们将递归地考虑出现在IMPL上的所有WHERE子句：如果这些子句匹配（或者我们不能排除它们匹配），那么这就是我们要选择的方法。否则，我们将继续执行一系列步骤。
