# 编译器源代码的天台风景

## Crate 结构

Rust 存储库主要包括一个`src`目录，该目录里面有许多箱子。这些箱子包含标准库和编译器的源代码。当然，本文档主要关注后者。

Rustc 由许多箱子组成，包括`syntax`，`rustc`，`rustc_back`，`rustc_codegen`，`rustc_driver`，还有更多。每个箱子的源代码可以在如`src/libXXX`的目录中找到，这里的`XXX`是箱子的名称。

（注意：这些箱子的名称和分区不是一成不变的，可能会随着时间的推移而改变。目前，我们倾向于更细粒度的划分，来帮助编译，尽管随着增量编译的改进，这种情况可能会有所改变。）

这些箱子的依赖结构，大致是一个菱形：

```text
                  rustc_driver
                /      |       \
              /        |         \
            /          |           \
          /            v             \
rustc_codegen  rustc_borrowck   ...  rustc_metadata
          \            |            /
            \          |          /
              \        |        /
                \      v      /
                    rustc
                       |
                       v
                    syntax
                    /    \
                  /       \
           syntax_pos  syntax_ext
```

这个`rustc_driver`箱子，在这个格子的顶部，实际上是 rust 编译器的“主要”函数。它没有太多“真正的代码”，而是将其他箱子中，定义的所有代码绑定在一起，并定义整个执行流程。（虽说我们越来越向[查询模型][query model]靠近，但是，编译“流程”的定义却越来越不集中。）

在菱形的另一个端，`rustc`箱定义了，所有其他编译器使用的常见和普遍的数据结构（例如，如何表示类型、trait 和程序本身）。它还包含一定数量的编译器本身，尽管相对来说比较有限。

最后，中间一排的所有箱子定义了编译器的主体 —— 它们都依赖`rustc`，以便它们可以使用，其中定义的各种类型，并导出公有程序，`rustc_driver`将根据需要调用（渐渐的，这些箱子都导出“查询定义”，但这些定义稍后会介绍到）。

`rustc`的下面，放置组成解析器和错误报告机制的各种箱子。由于历史原因，这些箱子没有`rustc_`前缀，但它们实际上只是编译器的内部环节，并不打算走向稳定（尽管，它们确实会被野外的一些箱子使用；我们希望逐步淘汰这种做法）。

每个箱子都有一个`README.md`，描述它所包含的高级抽象/思维，并试图给出某种解释（总有更好的）。

## 编译的主要阶段

<!-- ？？？查询模型 -->

Rust 编译器现在有点处于过渡期。它以前是一个纯粹的“基于过程”的编译器，我们在整个程序中运行了许多过程，每个过程都对转换进行了特定的检查。我们正在逐步用基于按需**查询**的备用设置，更换基于过程的代码。在查询模型中，我们重新出发，一个*查询*的执行表示我们的最终目标（例如“编译这个箱子”）。查询反过来也可以进行其他查询（例如，“给我一份箱子中，所有模块的列表”）。这些查询使其他查询，最终在基本操作凸显，比如分析输入、运行类型检查器等等。这个按需模型允许我们做一些令人兴奋的事情，比如对单个函数进行类型检查，只需最少的工作量。它还可以帮助进行增量编译。（有关，定义查询的详细信息，请查看[查询模型][query model]）

无论常规设置如何，编译器必须执行的基本操作都是相同的。唯一改变的是这些操作是流水调用还是按需调用。为了编译一个 Rust 箱子，我们一般采取以下步骤：

1.  **解析输入**
    - 这将处理`.rs`文件，并生成 ast（“抽象语法树”）
    - AST 的定义在`src/libsyntax/ast.rs`。它旨在与十分接近 Rust 语言的词汇语法匹配。
2.  **名称解析、宏扩展和配置**
    - 一旦解析完成，我们将递归地处理 AST，解析路径并展开宏。处理`#[cfg]`节点也会是同样的过程，和也可能会从 AST 中删除内容。
3.  **降层至 HIR**
    - 一旦名称解析完成，我们将 AST 转换为 HIR，或者“[高级中间描述][high-level intermediate representation]“。HIR 的定义在`src/librustc/hir/`；该模块还包括[降层][lowering]代码。
    - HIR 是 AST 的一个轻量级变体。它比 AST 处理得更多，更适合后续分析。它**不**需要匹配 rust 语言的语法。
    - 一个简单的例子，在**AST**，我们保留用户编写的括号，因此`((1 + 2) + 3)`和`1 + 2 + 3`会解析成不同的树，即使它们是等价的。然而，在 HIR 中，括号节点被删除，这两个表达式以相同的方式表示。
4.  **类型检查和后续分析**
    - 处理 HIR 的一个重要步骤是执行类型检查。例如，这个过程将类型分配给每个 HIR 表达式，并且还负责解析一些“类型-相关”的路径，例如字段访问（`x.f` —— 我们不知道`f`的字段访问，直到我们知道了`x`的类型）和关联的类型引用（`T::Item` —— 我们不知道`Item`的类型，直到我们知道`T`是什么）。
    - 类型检查创建“侧-表格”（`TypeckTables`）其中包括表达式的类型、解析方法的方式等等。
    - 在类型检查之后，我们可以进行其他分析，例如安全检查。
5.  **降层至 MIR 和处理后**
    - 一旦类型检查完成，我们可以将 HIR 降低到 MIR（“middle IR”），这是 Rust 一个**非常**脱皮的版本，非常适合 Borrowck，还肯定有高级优化。
6.  **转换为 LLVM 和 LLVM 优化**
    - 从 MIR，我们可以生产 LLVM IR。
    - 然后，LLVM 运行它的各种优化，从而生成一群`.o`文件（每个“codegen 单元”一个）。
7.  **链接**
    - 最后，把那些`.o`文件链接在一起。

[query model]: query.zh.html
[high-level intermediate representation]: hir.zh.html
[lowering]: lowering.zh.html
