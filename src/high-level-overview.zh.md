# 编译器源代码的高级概述

## 板条结构

主要的铁锈储存库包括`src`目录，里面有许多板条箱。这些板条箱包含标准库和编译器的源代码。当然，本文档主要关注后者。

Rustc由许多板条箱组成，包括`syntax`，`rustc`，`rustc_back`，`rustc_codegen`，`rustc_driver`以及更多。每个板条箱的来源可以在如下目录中找到`src/libXXX`在哪里`XXX`是板条箱的名称。

（注意：这些板条箱的名称和分区不是用石头砌成的，可能会随着时间的推移而改变。目前，我们倾向于使用更细粒度的划分来帮助编译时间，尽管随着增量编译的改进，这种情况可能会有所改变。）

这些板条箱的附属结构大致是一个菱形：

```text
                  rustc_driver
                /      |       \
              /        |         \
            /          |           \
          /            v             \
rustc_codegen  rustc_borrowck   ...  rustc_metadata
          \            |            /
            \          |          /
              \        |        /
                \      v      /
                    rustc
                       |
                       v
                    syntax
                    /    \
                  /       \
           syntax_pos  syntax_ext
```

这个`rustc_driver`板条箱，在这个格子的顶部，实际上是生锈编译器的“主要”功能。它没有太多“真正的代码”，而是将其他板条箱中定义的所有代码绑定在一起，并定义执行的整个流程。（随着我们越来越向[查询模型]但是，编译的“流程”越来越不集中定义。）

在另一个极端，`rustc`Crate定义了所有其他编译器使用的常见和普遍的数据结构（例如，如何表示类型、特征和程序本身）。它还包含一定数量的编译器本身，尽管这是相对有限的。

最后，中间凸起部分的所有板条箱定义了编译器的主体——它们都依赖于`rustc`，以便它们可以使用在其中定义的各种类型，并导出`rustc_driver`将根据需要调用（越来越多，这些板条箱导出的是“查询定义”，但稍后将介绍这些定义）。

下面`rustc`放置组成解析器和错误报告机制的各种板条箱。由于历史原因，这些板条箱没有`rustc_`前缀，但它们实际上只是编译器的内部部分，并不打算保持稳定（尽管它们最终会被野外的一些板条箱使用；我们希望逐步淘汰这种做法）。

每个板条箱都有一个`README.md`一种高级文件，描述它所包含的内容，并试图给出某种解释（有些比其他更好）。

## 汇编的主要阶段

Rust编译器现在有点过渡了。它以前是一个纯粹的“基于过程”的编译器，我们在整个程序中运行了许多过程，每个过程都对转换进行了特定的检查。我们正在逐步用基于按需设置的替代设置替换此基于通行证的代码。**查询**. 在查询模型中，我们向后工作，执行*查询*表示我们的最终目标（例如“编译这个板条箱”）。这个查询反过来也可以进行其他查询（例如，“给我一份板条箱中所有模块的列表”）。这些查询使其他查询最终在基本操作中触底，比如分析输入、运行类型检查器等等。这个按需模型允许我们做一些令人兴奋的事情，比如只做输入检查单个函数所需的最少工作量。它还可以帮助进行增量编译。（有关定义查询的详细信息，请查看[查询模型]）

无论常规设置如何，编译器必须执行的基本操作都是相同的。唯一改变的是这些操作是前后调用还是按需调用。为了编制锈箱，我们采取以下一般步骤：

1.  **解析输入**
    -   这将处理`.rs`文件并生成ast（“抽象语法树”）
    -   AST的定义在`src/libsyntax/ast.rs`. 它旨在与Rust语言的词汇语法非常接近。
2.  **名称解析、宏扩展和配置**
    -   一旦解析完成，我们将递归地处理AST，解析路径并展开宏。同样的过程也会处理`#[cfg]`节点，因此也可能会从AST中删除内容。
3.  **降低至HIR**
    -   一旦名称解析完成，我们将AST转换为HIR，或者“[高级中级代表-]“。HIR的定义见`src/librustc/hir/`；该模块还包括[降低]代码。
    -   hir是ast的一个轻减变体。它比AST处理得更多，更适合后续分析。它是**不**需要匹配rust语言的语法。
    -   作为一个简单的例子，**AST**，我们保留用户编写的括号，因此`((1 + 2) + 3)`和`1 + 2 + 3`解析成不同的树，即使它们是等价的。然而，在hir中，括号节点被删除，这两个表达式以相同的方式表示。
4.  **类型检查和后续分析**
    -   处理hir的一个重要步骤是执行类型检查。例如，这个过程将类型分配给每个HIR表达式，并且还负责解析一些“依赖类型”的路径，例如字段访问（`x.f`–我们不知道哪个领域`f`直到我们知道`x`）和关联的类型引用（`T::Item`–我们不知道是哪种类型`Item`直到我们知道`T`是）。
    -   类型检查创建“侧表”（`TypeckTables`）其中包括表达式的类型、解析方法的方法等等。
    -   在类型检查之后，我们可以进行其他分析，例如隐私检查。
5.  **降低到MIR和后处理**
    -   一旦类型检查完成，我们可以将hir降低到mir（“middle ir”），这是一个**非常**铁锈脱皮版，非常适合Borrowck，也可以对某些高级优化。
6.  **转换为llvm和llvm优化**
    -   从MIR，我们可以生产LLVM IR。
    -   然后，LLVM运行其各种优化，从而生成`.o`文件（每个“codegen单元”一个）。
7.  **链接**
    -   最后，那些`.o`文件链接在一起。

[query model]: query.html

[high-level intermediate representation]: hir.html

[lowering]: lowering.html
