该文件提供了有关rustc编码约定的一些提示。本章包括[格式化](#formatting)，[编码正确性](#cc)，[使用来自crates.io的板条箱](#cio)，以及一些提示[构建您的公关以便于审核](#er)。

<a name="formatting"></a>

# 格式化和整洁的脚本

rustc慢慢朝着[Rust标准编码风格][fmt];然而，此刻，它遵循了更多*混乱的*样式。我们确实有一些强制格式约定，这些约定由我们亲切地称为“整洁”脚本的脚本自动强制执行。当你这样做时，整洁的脚本会自动运行`./x.py test`并且可以与...分开运行`./x.py test src/tools/tidy`。

[fmt]: https://github.com/rust-lang-nursery/fmt-rfcs

<a name="copyright"></a>

### 版权声明

某些现有文件以版权和许可声明开头。对于根据标准条款（双MIT / Apache-2.0）许可的新文件，请忽略此通知。对于现有文件，顶部的年份没有意义：从作者身份开始，版权保护实际上是自动的。我们通常不会在现有文件上编辑年份。

## 线长

行最多100个字符。如果你可以保持80岁，那就更好了。

**忽略行长度限制。**有时 - 特别是对于测试 - 可能有必要免除此限制。在这种情况下，您可以在文件顶部添加注释（在版权声明之后），如下所示：

```rust
// ignore-tidy-linelength
```

## 标签与空格

喜欢4个空格的缩进。

<a name="cc"></a>

# 编码的正确性

除了格式化之外，还有一些值得关注的其他提示。

## 喜欢详尽的比赛

运用`_`在匹配中很方便，但这意味着当新的变体添加到枚举时，它们可能无法正确处理。问问自己：如果在这个枚举中添加了一个新的变体，它有什么机会想要使用它`_`代码，与其他一些治疗相比？除非答案是“低”，否则更喜欢详尽的匹配。（同样的建议适用于`if let`和`while
let`，这是对单个变体的有效测试。）

## 对于您不想忘记的事情，请使用“TODO”评论

作为一个有用的工具，你可以插入一个`// TODO`评论您在登陆PR之前想要回复的事情：

```rust,ignore
fn do_something() {
    if something_else {
        unimplemented!(); // TODO write this
    }
}
```

整洁的脚本将报告错误`// TODO`注释，所以这个代码在修复（或删除）TODO之前无法着陆。

这在PR中也很有用，因为它可以从一个提交中发出信号，告知您将留下以后提交将修复的错误：

```rust,ignore
if foo {
    return true; // TODO wrong, but will be fixed in a later commit
}
```

<a name="cio"></a>

# 使用来自crates.io的板条箱

允许使用crates.io中的crates，但不应无偿添加外部依赖项。所有这些板条箱必须具有适当的许可证。有一个自动检查，检查货物元数据，以确保这一点。

<a name="er"></a>

# 如何构建您的公关

如何准备PR中的提交可以为审阅者带来很大的不同。这里有一些提示。

**将“纯重构”分离为自己的提交。**例如，如果重命名方法，则将该重命名放入其自己的提交中，同时重命名所有用法。

**更多提交通常更好。**如果你正在进行大的改变，那么将它分解成可以独立理解的较小步骤几乎总是更好。需要注意的一件事是，如果您在一个策略之后引入一些代码，那么在稍后的提交中将其显着更改（而不是添加到它），“来回”可能会让人感到困惑。

**如果您运行rustfmt并且文件尚未格式化，请将其隔离到自己的提交中。**这与之前的规则非常相似，但值得强调。rustfmt文件是可以的，但由于我们目前不会一直运行rustfmt，这会给你的提交带来很多噪音。请将其隔离到自己的提交中。这也使得rebase不那么痛苦，因为rustfmt往往会导致很多合并冲突，并且将那些孤立到自己的提交中使得它们更容易解决。

**没有合并。**除了bors之外，我们不允许将合并提交到我们的历史中。如果你遇到合并冲突，可以通过命令来改造`git rebase -i rust-lang/master`（假设你使用这个名字`rust-lang`为你的遥控器）。

**个人提交不必构建（但它很好）。**我们不要求每个中间提交都成功构建 - 我们只希望能够在PR级别上进行二等分。但是，如果你*能够*使个人提交构建，这总是有帮助的。
