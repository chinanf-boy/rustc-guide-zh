# 演练：典型贡献

有*很多*为Rust编译器做出贡献的方法，包括修复错误、提高性能、帮助设计功能、提供现有功能的反馈等。本章并不声称会刮伤表面。相反，它完成了一个新特性的设计和实现。并非这里描述的所有步骤和过程都需要为每个贡献，我将在它们出现时尝试指出这些步骤和过程。

一般来说，如果你有兴趣做出贡献，不确定从哪里开始，请随时询问！

## 概述

我将在本章中讨论的特征是`?`宏的Kleene运算符。基本上，我们希望能够写这样的东西：

```rust,ignore
macro_rules! foo {
    ($arg:ident $(, $optional_arg:ident)?) => {
        println!("{}", $arg);

        $(
            println!("{}", $optional_arg);
        )?
    }
}

fn main() {
    let x = 0;
    foo!(x); // ok! prints "0"
    foo!(x, x); // ok! prints "0 0"
}
```

所以基本上，`$(pat)?`宏中的matcher表示“此模式可以发生0或1次”，类似于其他regex语法。

从一个想法到稳定的锈迹特征有很多步骤。这是一个快速列表。我们将按照下面的顺序逐一进行。正如我之前提到的，并非所有这些都是每种贡献所必需的。

-   **想法讨论/预RFC**预RFC是功能的早期草稿或设计讨论。这一阶段的目的是使设计空间有一点充实，并用一个想法来把握不同的优点和问题。这是一个很好的方法，可以在向更广泛的受众介绍您的想法之前尽早获得反馈。你可以找到最初的讨论[在这里][prerfc].
-   **RFC**这是你正式向社区提出你的想法以供考虑的时候。你可以找到RFC[在这里][rfc].
-   **实施**在编译器中不稳定地实现您的想法。您可以找到原始的实现[在这里][impl1].
-   **可能重复/优化**当社区在夜间编译器和`libstd`，可能会有关于设计选择的其他反馈，这些反馈可能会被调整。这个特别的功能[通过][impl2]一[数][impl3]属于[迭代][impl4].
-   **稳定**当你的特征已经烤够了，一个铁锈小组成员可能[建议稳定][merge]. 如果达成共识，就可以做到。
-   **放松**您的功能现在是一个稳定的生锈功能！

[prerfc]: https://internals.rust-lang.org/t/pre-rfc-at-most-one-repetition-macro-patterns/6557

[rfc]: https://github.com/rust-lang/rfcs/pull/2298

[impl1]: https://github.com/rust-lang/rust/pull/47752

[impl2]: https://github.com/rust-lang/rust/pull/49719

[impl3]: https://github.com/rust-lang/rust/pull/51336

[impl4]: https://github.com/rust-lang/rust/pull/51587

[merge]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613

## 预RFC和RFC

> 注：一般来说，如果你不建议*新的*特性或对铁锈或生态系统的实质性改变，您不需要遵循RFC过程。相反，你可以直接跳到[实施](#impl).
>
> 您可以找到有关何时打开RFC的官方指南。[在这里][rfcwhen].

[rfcwhen]: https://github.com/rust-lang/rfcs#when-you-need-to-follow-this-process

RFC是一个描述您正在详细提议的特性或变更的文档。任何人都可以编写一个RFC；这个过程对每个人都是一样的，包括Rust团队成员。

要打开RFC，请在[锈郎/RFCs](https://github.com/rust-lang/rfcs)在Github上回购。您可以在[自述文件](https://github.com/rust-lang/rfcs#what-the-process-is).

在打开一个RFC之前，你应该做一些研究来“充实”你的想法。仓促提出的RFC往往不被接受。您通常应该对动机、影响、缺点以及与其他特性的潜在交互有一个良好的描述。

如果这听起来像是很多工作，那是因为它是。但没有恐惧！即使你不是一个编译器黑客，你也可以通过做一个*预RFC*. 这是一个*非正式的*讨论这个想法。最好的地方是internals.rust-lang.org。你的文章不需要遵循任何特定的结构。它甚至不需要是一个有凝聚力的想法。一般来说，你会得到大量的反馈，你可以整合回来产生一个好的RFC。

（另一个专业提示：尝试搜索RFC回购和内部结构以获取先前的相关想法。很多时候，一个想法已经被考虑过，要么被拒绝，要么被推迟到稍后再试。这样可以节省你和其他人的时间）

在我们的示例中，pre-rfc线程中的一个参与者指出了语法不明确和潜在的解决方案。此外，总体反馈似乎是积极的。在这种情况下，讨论很快就集中了，但是对于某些想法，可能会发生更多的讨论（例如，请参见[这个RFC][nonascii]收到了684条评论！）如果发生这种情况，不要泄气；这意味着社区对你的想法感兴趣，但它可能需要一些调整。

[nonascii]: https://github.com/rust-lang/rfcs/pull/2457

我们的RFC`?`宏功能也收到了一些关于RFC线程的讨论。与大多数RFC一样，有一些问题我们无法通过讨论来回答：我们需要经验来使用该特性来决定。这些问题列在RFC的“未解决问题”部分。此外，在RFC讨论过程中，您可能希望更新RFC文档本身以反映讨论过程（例如，可能会添加新的替代方案或先前的工作，或者您可能决定更改建议本身的部分内容）。

最后，当讨论似乎达成共识并有一点失败时，一个生锈小组成员可以提议通过三种可能的处置方式之一转移到FCP。这意味着他们希望适当团队的其他成员对RFC进行审查和评论。接下来可能会有更多的讨论，这可能导致更多的变化或未解决的问题被添加。在某种程度上，当所有人都满意时，RFC进入“最终评论期”（FCP），这是人们提出异议的最后机会。FCP结束后，采取处置措施。以下是三种可能的处置方式：

-   *合并*：接受功能。这是我们合并的建议[`?`宏观特征][rfcmerge].
-   *关闭*：当前形式的此功能不适合生锈。如果这发生在你的RFC上，不要气馁，也不要把它当面看待。这不是对你的反思，而是一个社会决定，即生锈将朝着不同的方向发展。
-   *推迟*：有兴趣朝这个方向走，但目前没有。这种情况经常发生，因为适当的Rust团队没有带宽来引导特性通过过程达到稳定。通常情况下，当该特性不符合团队的路线图时。推迟的想法稍后可能会被重新考虑。

[rfcmerge]: https://github.com/rust-lang/rfcs/pull/2298#issuecomment-360582667

当一个RFC被合并时，PR被合并到RFC回购中。一个新的*跟踪问题*创建于[锈郎-锈/]repo跟踪功能的进度，讨论未解决的问题、实现进度和拦截器等。下面是我们的跟踪问题[`?`宏观特征][tracking].

[tracking]: https://github.com/rust-lang/rust/issues/48075

<a name="impl"></a>

## 实施

要更改编译器，请针对[锈郎-锈/]回购协议。

[rust-lang/rust]: https://github.com/rust-lang/rust

根据特性/更改/错误修复/改进，实现可能相对简单，也可能是一项重要的工作。您可以向经验更丰富的编译器开发人员寻求帮助或指导。此外，您不必是实现您的特性的人；但是请记住，如果您不这样做，可能需要一段时间，其他人才能做到。

对于`?`宏特性，我需要去了解编译器中宏扩展的相关部分。就我个人而言，我发现[改进意见][comments]在代码中是确保我理解它的一种有用的方法，但是如果你不想这样做的话，你不必这样做。

[comments]: https://github.com/rust-lang/rust/pull/47732

然后我[实施][impl1]原始特性，如RFC中所述。当实现新特性时，它将落后于*特征门*也就是说你必须使用`#![feature(my_feature_name)]`使用功能。特征门在特征稳定后被移除。

**大多数错误修复和改进**不需要功能入口。您只需进行更改/改进。

当你在[锈色-锈色/]一个机器人会将你的公关分配给一个评论。如果您正在与某个特定的Rust团队成员合作，您可以通过在线程上留下评论来请求该审阅者`r?
@reviewer-github-id`（例如`r? @eddyb`）。如果你不知道该向谁请求，就不要向任何人请求；bot将自动分配某人。

审核人可能会在批准您的公关之前要求更改。请随时提出问题或讨论您不理解或不同意的事情。但是，要认识到，除非有人同意，否则公关不会被合并。

当您的审查批准了PR时，它将进入另一个名为`@bors`.  `@bors`管理CI生成/合并队列。当你的公关达到`@bors`排队，`@bors`将通过在Travis CI上对您的PR运行所有测试来测试合并。从这篇文章开始大约需要2个小时。如果所有测试都通过，那么pr将被合并，并成为下一个夜间编译器的一部分！

在审查过程中，一些PRS可能会发生一些事情。

-   如果变更足够大，审查员可以要求公关部提供一份FCP。这给了适当团队的所有成员审查变更的机会。
-   如果更改可能导致损坏，则审阅者可以请求[陨石坑]跑。这将使用您的更改编译编译器，然后尝试使用修改后的编译器编译ractes.io上的所有板条箱。这是一个很好的冒烟测试，用于检查您是否引入了对编译器行为的更改，该更改会影响很大一部分生态系统。
-   如果您的pr差异较大或审阅者正忙，则您的pr可能与其他碰巧首先合并的pr发生合并冲突。您应该使用普通的git过程来修复这些合并冲突。

[crater]: ./tests/intro.html#crater

如果你没有做一个新的功能或者类似的事情（例如，如果你正在修复一个bug），那就是它了！感谢您的贡献：）

## 改进您的实施

当人们在夜间体验到您的新功能时，可能会提出一些细微的更改，并且可能会解决未解决的问题。如上文所述，更新/变更执行任何其他变更的过程相同（即提交一份公关、审查、等待`@bors`等）。

一些变化可能会非常严重，需要一个FCP和一些由Rust团队成员审查。

对于`?`宏特性，我们在原始实现之后进行了一些不同的迭代：[一][impl2]，[二][impl3]，[三][impl4].

一路上，我们决定`?`不应该使用分隔符，这是在RFC中列出的一个未解决的问题。我们还改变了消除歧义的策略：我们决定取消使用`?`该分离器是重复的其他运营商（例如，令牌`+`或`*`）。然而，由于这是突发的变化，我们决定在一个版，它的边界。因此，新的功能可以被激活只有在2018年版。这些deviations要求从原来的RFC[另一个阶段](https://github.com/rust-lang/rust/issues/51934)。。。。。。。

## 镇定

最后，烤后的特征是在夜间有团队成员在线，语言[它移动到stabilize][stabilizefcp]。。。。。。。

[stabilizefcp]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613

A *稳定报告*这是书面的需求包括：

-   简明描述的任何行为和deviations从RFC
-   这版是如何影响和（S）
-   链接到一些有趣的测试方面的表现

我们的报告是一个稳定的特征[在这里][stabrep]。。。。。。。

[stabrep]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433243048

在这，[PR是用][stab]消除的功能，使门的功能，默认情况下（在2018年版）。是由注意到[释放笔记][relnotes]我们的特征。

stabilize措施的特征，可以发现在[稳定的特征](./stabilization_guide.md)。。。。。。。

[relnotes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md
