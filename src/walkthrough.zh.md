# 演练：贡献示例

有*很多*为 Rust 编译器做出贡献的方法，包括修复错误、提高性能、帮助设计功能、提供现有功能的反馈等。本章声明，并不会只刮表面。相反，它完成了一个新特性的设计和实现。这里并非描述所有步骤和过程，且不是每个贡献都需要，我将在它们出现时，尝试指点这些步骤和过程。

一般来说，如果你有兴趣做出贡献，不确定从哪里开始，请随时询问！

## 概述

我将在本章中讨论的功能是，宏中的`?`Kleene 运算符。基本上，我们希望能够写这样的东西：

```rust,ignore
macro_rules! foo {
    ($arg:ident $(, $optional_arg:ident)?) => {
        println!("{}", $arg);

        $(
            println!("{}", $optional_arg);
        )?
    }
}

fn main() {
    let x = 0;
    foo!(x); // ok! prints "0"
    foo!(x, x); // ok! prints "0 0"
}
```

所以基本上，宏中的`$optional_arg:ident)?` matcher 表示“此模式可以发生 0 或 1 次”，类似于 regex 语法。

从一个想法到稳定的 Rust 功能有很多步骤。这是一个快速列表。我们将按照下面的顺序逐一进行。正如我之前提到的，并非所有的每个贡献都需要。

- **想法讨论/预 RFC** 预 RFC 是功能的早期草稿或设计讨论。这一阶段的目的是使设计空间有一点充实，并把握想法的不同的优点和问题。这是一个很好的方法，可以在向更广泛的受众介绍您的想法之前，尽早获得反馈。你可以[在这里][prerfc]找到最初的讨论。
- **RFC** 这是你正式向社区提出你的想法，以供考虑的时候。你可以[在这里][rfc]找到 RFC。
- **实现** 在编译器中不稳定地实现您的想法。您可以[在这里][impl1]找到原始的实现。
- **可能重复/优化** 当社区在夜间编译器和`libstd`中实验你的功能，可能会有关于设计选择的其他反馈，这些反馈可能会被调整。这个特定的功能会[通过][impl2]一定[数量][impl3]的[迭代][impl4]。
- **稳定** 当你的功能已经烤够了，一个 Rust 小组成员可能[建议稳定它][merge]。 如果达成共识，就可以完成了。
- **搞定** 您的功能现在是一个稳定的 Rust 功能！

[prerfc]: https://internals.rust-lang.org/t/pre-rfc-at-most-one-repetition-macro-patterns/6557
[rfc]: https://github.com/rust-lang/rfcs/pull/2298
[impl1]: https://github.com/rust-lang/rust/pull/47752
[impl2]: https://github.com/rust-lang/rust/pull/49719
[impl3]: https://github.com/rust-lang/rust/pull/51336
[impl4]: https://github.com/rust-lang/rust/pull/51587
[merge]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613

## 预 RFC 和 RFC

> 注：一般来说，如果你不建议*新的*特性或对铁锈或生态系统的实质性改变，您不需要遵循 RFC 过程。相反，你可以直接跳到[实施](#impl).
>
> 您可以找到有关何时打开 RFC 的官方指南。[在这里][rfcwhen].

[rfcwhen]: https://github.com/rust-lang/rfcs#when-you-need-to-follow-this-process

RFC 是一个描述您正在提议的特性或变更的详细文档。任何人都可以编写一个 RFC；这个过程对每个人都是一样的，包括 Rust 团队成员。

要打开一个 RFC，请在 Github 上[rust-lang/rfcs](https://github.com/rust-lang/rfcs) 打开一个 PR。您可以在[readme](https://github.com/rust-lang/rfcs#what-the-process-is)找到细节描述。

在打开一个 RFC 之前，你应该做一些研究来“充实”你的想法。仓促提出的 RFC 往往不被接受。您通常应该对动机、影响、缺点以及与其他特性的潜在交互，有一个良好的描述。

如果这听起来像是很多工作，那正因为它确实如此。但不要恐惧！即使你不是一个编译器黑客，你也可以通过做一个*预 RFC*，获得高经验回报。一个*非正式*想法的讨论，最好的地方是 internals.rust-lang.org。你的文章不需要遵循任何特定的结构。它甚至不需要是一个具有核心的想法。一般来说，你会得到大量的反馈，你可以整合在一起，产生一个好的 RFC。

（另一个专业提示：尝试搜索这个 RFC 存储库，以获取先前的内部相关想法。很多时候，会存在，一个想法已经被考虑过，要么被拒绝，要么被推迟到稍后再试。这样可以节省你和其他人的时间）

在我们的示例中，pre-rfc 线程中的一个参与者，指出了语法不明确和潜在的解决方案。此外，总体反馈似乎是积极的。在这种情况下，讨论很快就集中起来，但是对于某些想法，可能会发生更多的讨论（例如，请参见[这个 RFC][nonascii]，收到了 684 条评论！）如果发生这种情况，不要泄气；这意味着社区对你的想法感兴趣，但它可能需要一些调整。

[nonascii]: https://github.com/rust-lang/rfcs/pull/2457

我们`?`宏功能的 RFC 也收到了一些讨论。与大多数 RFC 一样，有一些问题我们无法通过讨论来回答：我们需要使用该功能的经验来决定。这些问题列在 RFC 的“未解决问题”部分。此外，在 RFC 讨论过程中，您可能希望更新 RFC 本身的文档，反映讨论过程（例如，可能会添加新的替代方案或先前的工作，或者您可能决定更改提议本身的部分内容）。

最后，当讨论似乎达成共识，且只有一点问题时，一个 Rust 小组成员可以提议，通过三种可能的处置方式之一，来转移到 FCP。这意味着他们希望合适团队的其他成员对 RFC 进行审查和评论。接下来可能会有更多的讨论，这可能导致更多的变化或未解决的问题被添加。在某种程度上，当所有人都满意时，RFC 进入“最终评论期”（FCP），这是人们提出异议的最后机会。FCP 结束后，采取处置措施。以下是三种可能的处置方式：

- _合并(Merge)_：接受功能。这是我们[`?`宏功能][rfcmerge]的合并提议。
- _关闭(Close)_：当前形式的此功能不适合 Rust。如果这发生在你的 RFC 上，不要气馁，也不要把它看成个人问题。这不是个人，而是一个社会决定 Rust 朝着哪个方向发展。
- _推迟(Postpone)_：有兴趣，但目前没有。这种情况经常发生，因为合适的 Rust 团队没有'带宽'，来引导功能达到稳定。通常情况下，当该功能不符合团队的开发路线图时，推迟的想法稍后可能会被重新考虑。

[rfcmerge]: https://github.com/rust-lang/rfcs/pull/2298#issuecomment-360582667

当一个 RFC 被合并时，该 PR 被合并到 RFC 存储库中。一个新的*跟踪问题*在[rust-lang/rust]创建，用来跟踪功能的进度，讨论未解决的问题、实现进度和拦截器等。下面是我们[`?`宏观功能][tracking]的跟踪问题。

[tracking]: https://github.com/rust-lang/rust/issues/48075

<a name="impl"></a>

## 实现

要对编译器进行更改，请针对[rust-lang/rust]存储库打开一个 PR。

[rust-lang/rust]: https://github.com/rust-lang/rust

根据 feature/change/bug fix/improvement，实现可能相对简单，也可能是一项重要的工作。您可以向经验更丰富的编译器开发人员寻求帮助或指导。此外，您不必是实现您功能的人；但是请记住，如果您不这样做，可能需要一段时间，其他人才会去做。

对于`?`宏功能，我需要去了解编译器中，宏扩展的相关部分。就我个人而言，我发现在代码中，[改进意见][comments]是确保我理解它的一种有用的方法，但是如果你不想这样做的话，不必这样做。

[comments]: https://github.com/rust-lang/rust/pull/47732

然后我[实现][impl1]原始功能，如 RFC 中所述。当实现新特性时，它将落户到*feature gate*，也就是说你必须用`#![feature(my_feature_name)]`，才能使用功能。在功能稳定后，相关 feature gate 被移除。

**大多数错误修复和改进**不需要 feature gate。您只需进行更改/改进。

当你在[rust-lang/rust]打开一个 PR，一个机器人会将你的 PR 分配给一个审查员。如果您正在与某个特定的 Rust 团队成员合作，您可以通过留下评论来请求该审查员`r? @reviewer-github-id`（例如`r? @eddyb`）。如果你不知道该向谁请求，就不要向任何人请求；bot 将自动分配某人。

审查员可能会在批准您的 PR 之前要求更改。请随时提出问题或讨论您不理解或不同意的事情。但是，要认识到，除非有人同意，否则 PR 不会被合并。

当您的 PR 批准时，它将进入另一个名为`@bors`的队列。 `@bors`管理 CI 构建/合并队列。当你的 PR 到`@bors`那排队，`@bors`会通过在 Travis CI 上对您的 PR 运行所有测试，来测试合并的 PR。如本次示例大约需要 2 个小时。如果所有测试都通过，那么 pr 将被合并，并成为下一个夜间编译器的一部分！

在审查过程中，一些 PR 可能会发生一些事情。

- 如果变更足够大，审查员可以要求在这 PR 上，提供一份 FCP。这给了适当团队的所有成员，审查变更的机会。
- 如果更改可能导致损坏，则审查员可以请求启动一个[crater]。这将编译您更改了的编译器，然后尝试使用修改后的编译器，编译 crates.io 上的所有箱。这是一个很好的烟幕测试，用于检查您引入对编译器行为的更改，是否造成生态系统很大部分的影响。
- 如果您的 pr 差异较大或审查员正忙，则您的 pr 可能与其他碰巧首先合并的 pr 发生合并冲突。您应该使用正常的 git 过程，来修复这些合并冲突。

[crater]: ./tests/intro.zh.html#crater

如果你没有做一个新的功能，但做了类似的事情（例如，如果你正在修复一个 bug），就是它！同样感谢您的贡献 :）

## 改进您的实现

当人们在夜间体验到您的新功能时，可能会提出一些细微的更改，并且可能会解决未解决的问题。如上文所述，任何其他的更新/变更，与上述过程相同（即提交一份 PR、审查、等待`@bors`等）。

一些变化可能会非常重大，需要一个 FCP 和一些由 Rust 团队成员审查。

对于`?`宏功能，我们在原始实现之后，进行了一些不同的迭代：[一][impl2]，[二][impl3]，[三][impl4]。

一路上，我们决定`?`不应该使用分隔符，这是在 RFC 中列出的一个未解决的问题。我们还改变了消除歧义的策略：我们决定取消使用`?`，作为其他重复运算符的分隔符标记的能力（例如，`+`或`*`）。然而，由于这是突兀的变化，我们决定在一个年版，定一个边界。因此，新的功能只有在 2018 版，可以被激活。原来的 RFC 需求[另一个 FCP](https://github.com/rust-lang/rust/issues/51934)的争论。

## 稳定

最后，烤好的功能会在夜间版本一阵子，语言团队成员把[它移动到 stabilize][stabilizefcp]。

[stabilizefcp]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613

一份 _稳定报告_，书面的需求包括：

- 简明描述的任何行为和 RFC 的 任何偏差
- 哪个版本被影响和如何被影响
- 链接到一些测试，展示有趣的方面

我们功能的稳定报告[在这里][stabrep]。

[stabrep]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433243048

在这之后，[创建一个 PR][stab]移除 feature gate，默认情况下启动该功能（在 2018 年版。[版本笔记][relnotes]添加我们功能的记录。

稳定功能的步骤，可以在[功能的稳定过程](./stabilization_guide.zh.md)找到。

[relnotes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md
