# 跟踪移动和初始化

借用检查员的部分工作是跟踪在任何给定时间点“初始化”哪些变量 - 这还需要确定移动发生的位置并跟踪这些变量。

## 初始化和移动

从用户的角度来看，初始化 - 给变量赋予一些价值 - 并移动 - 将所有权转移到另一个地方 - 可能看起来像是不同的主题。实际上，我们的借用检查器错误消息通常以不同方式讨论它们。但**在借阅检查器内**，他们几乎没有分开。粗略地说，借用检查器跟踪源代码中任何一点的“初始化位置”集。分配给先前未初始化的局部变量会将其添加到该集合中;从局部变量移动将其从该集合中移除。

考虑这个例子：

```rust,ignore
fn foo() {
    let a: Vec<u32>;
    
    // a is not initialized yet
    
    a = vec![22];
    
    // a is initialized here
    
    std::mem::drop(a); // a is moved here
    
    // a is no longer initialized here

    let l = a.len(); //~ ERROR
}
```

在这里你可以看到`a`从未初始化开始;一旦分配，它就会被初始化。但当`drop(a)`被称为，移动`a`进入呼叫，因此它再次未初始化。

## 小节

为了便于细读，本节分为若干小节：

-   [移动路径](./moves_and_initialization/move_paths.html)该*移动路径*我们用来跟踪哪些局部变量（或局部变量的一部分，在某些情况下）被初始化的概念。
-   去做*休息尚未写*=）
