# 特征分辨力（老式）

本章介绍了*特征分辨力*并指出一些不明显的事情。

**注：**本章（及其分章）描述了特征求解器**目前**作品。然而，我们正在设计一个新的特性求解器。如果你想了解*那个*见[*这*特色章](./index.html).

## 主要概念

特征解析是将IMPL与每个特征引用配对的过程。例如，如果有一个通用函数，比如：

```rust,ignore
fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }
```

然后调用该函数：

```rust,ignore
let v: Vec<isize> = clone_slice(&[1, 2, 3])
```

找出（在本例中）是否存在`isize : Clone`.

注意，在某些情况下，像通用函数一样，我们可能找不到特定的impl，但是我们可以发现调用者必须提供一个impl。例如，考虑`clone_slice`：

```rust,ignore
fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {
    let mut v = Vec::new();
    for e in &x {
        v.push((*e).clone()); // (*)
    }
}
```

标线`(*)`只有在以下情况下才合法`T`（类型）`*e`）实现`Clone`特质。当然，因为我们不知道`T`是的，我们找不到特定的impl；但是基于绑定`T:Clone`我们可以说，存在一个调用方必须提供的IMPL。

我们使用这个词*义务*指需要执行impl的特征引用。基本上，特征解决系统通过证明适当的IMPL确实存在来解决一项义务。

在类型检查期间，我们不存储特性选择的结果。我们只是想验证特征选择是否会成功。然后，在trans时，当我们有了所有具体的类型可用时，我们可以重复特性选择来选择实际的实现，然后在输出二进制文件中生成。

## 概述

特征分辨包括三个主要部分：

-   **选择**：决定如何解决特定义务。例如，选择可能决定通过使用与`Self`类型，或使用参数绑定（例如`T: Trait`）在IMPL的情况下，选择一个义务可以创建*嵌套义务*因为IMPL本身的WHERE子句。它还可能需要评估这些嵌套的义务，以解决含糊不清的问题。

-   **履行**：履行代码是跟踪义务完全履行的代码。基本上，它是要选择的义务的工作列表：一旦选择成功，该义务将从工作列表中移除，并且任何嵌套的义务都将排队。

-   **一致性**：一致性检查旨在确保不存在重叠的impl，其中两个impl可以以相同的优先级使用。

## 选择

选择是决定某项义务是否可以解决以及如何解决（通过IMPL、WHERE子句等）的过程。主界面是`select()`函数，它承担义务并返回`SelectionResult`. 有三种可能的结果：

-   `Ok(Some(selection))`–是的，义务可以解决，并且`selection`指示如何。如果IMPL是通过IMPL解决的，那么`selection`还可以指示IMPL所需的嵌套义务。

-   `Ok(None)`–我们还不确定该义务是否可以解决。当义务包含未绑定的类型变量时，这种情况最常见。

-   `Err(err)`–由于类型错误或没有可能适用的IMPLS，无法解决该义务。

选择的基本算法分为两大阶段：候选装配和确认。

请注意，由于生命周期推断是如何工作的，因此不可能立即反馈生命周期之间的统一关系或子类型关系是否存在。因此，寿命匹配是*不*在选择过程中考虑。这反映在这样一个事实上：分区分配是绝对正确的。这可能会产生寿命约束，稍后会发现这些约束存在错误（相反，非寿命约束在选择过程中已经过检查，并且永远不会导致错误，尽管它们自然会导致下游的其他错误）。

### 候选程序集

搜索可能用于履行义务的impls/where子句/etc。每个人都被称为候选人。为了避免歧义，我们希望找到一个完全适用的候选人。在某些情况下，我们可能不知道IMPL/WHERE子句是否适用——当义务包含未绑定的推理变量时，就会发生这种情况。

决定特定impl/where子句/etc是否适用于特定义务的子程序统称为*匹配*.目前，这相当于统一`Self`类型，但在将来，在IMPL的情况下，我们也可以递归地考虑一些嵌套的义务。

**托多**：什么是“统一`Self`“类型”是指？这个`Self`关于IMPL的义务？

候选人大会的基本思想是做第一次通过，我们确定所有可能的候选人。在这个过程中，我们所做的就是尝试统一类型参数。（特别是，我们忽略任何嵌套的WHERE子句。）假定统一成功，IMPL将作为候选项添加。

第一次通过后，我们可以检查一组候选人。如果它是一个单例集，那么我们就完成了：这是作用域中唯一可能应用的impl。否则，我们可以通过使用WHERE子句和其他条件来筛选候选集。如果这个减少的集合生成一个单一的、明确的条目，我们就可以继续了，否则结果被认为是不明确的。

#### 基本过程：根据我们看到的IMPLS推断

如果我们通过一些例子，这个过程会更简单。考虑以下特点：

```rust,ignore
trait Convert<Target> {
    fn convert(&self) -> Target;
}
```

这个特性只有一种方法。就这么简单。它转换自（隐式）`Self`键入`Target`类型。如果我们想允许`isize`和`usize`，我们可以实现`Convert`像这样：

```rust,ignore
impl Convert<usize> for isize { ... } // isize -> usize
impl Convert<isize> for usize { ... } // usize -> isize
```

现在假设有如下代码：

```rust,ignore
let x: isize = ...;
let y = x.convert();
```

要转换的调用将生成特征引用`Convert<$Y> for
isize`在哪里`$Y`是表示类型的类型变量`y`. 在我们能看到的两个例子中，唯一匹配的是`Convert<usize> for isize`. 因此，我们可以选择这个IMPL，这将导致`$Y`统一到`usize`. （请注意，在组装候选对象时，我们在事务中进行初始统一，这样它们就不会相互影响。）

**托多**：该示例说我们可以“选择”IMPL，但本节专门讨论候选程序集。这是否意味着我们有时可以跳过确认？还是措辞不当？**托多**：是`$Y`特性解析或类型推断的一部分？或者这与类型推理中的“推理变量”类型不同？

#### 赢：解决歧义

但是如果在所有类型都统一的地方存在多个impl，会发生什么呢？考虑这个例子：

```rust,ignore
trait Get {
    fn get(&self) -> Self;
}

impl<T:Copy> Get for T {
    fn get(&self) -> T { *self }
}

impl<T:Get> Get for Box<T> {
    fn get(&self) -> Box<T> { Box::new(get_it(&**self)) }
}
```

当我们调用`get_it(&Box::new(1_u16))`比如说？在这种情况下，`Self`类型是`Box<u16>`–这与两个IMPLS结合在一起，因为第一个应用于所有类型`T`第二个是`Box<T>`. 为了使其明确，编译器将执行*簸选*考虑通过`where`删除候选项的子句和尝试。在这种情况下，第一个IMPL仅适用于`Box<u16> : Copy`，这不适用。赢了之后，我们只剩下一个候选人，所以我们可以继续。

#### `where`条款

除了IMPL之外，解决债务的另一个主要方法是通过WHERE子句。选择过程总是给出一个[参数环境]其中包含一个WHERE条款列表，这些条款基本上是我们可以承担的义务。我们将迭代该列表，并检查是否可以在该列表中找到我们当前的义务。如果是这样，就被认为是满意的。更准确地说，我们想检查是否有一个WHERE子句义务是针对相同的特性（或某些子图），并且可以与该义务相匹配。

[parameter environment]: ../param_env.html

考虑这个简单的例子：

```rust,ignore
trait A1 {
    fn do_a1(&self);
}
trait A2 : A1 { ... }

trait B {
    fn do_b(&self);
}

fn foo<X:A2+B>(x: X) {
    x.do_a1(); // (*)
    x.do_b();  // (#)
}
```

体内`foo`很明显我们可以使用`A1`，`A2`或`B`关于变量`x`. 标线`(*)`将承担一项义务`X: A1`，而该行标记`(#)`将承担一项义务`X: B`. 同时，参数环境将包含两个where子句：`X : A2`和`X : B`. 对于每一项义务，然后，我们搜索这个WHERE子句列表。义务`X: B`与WHERE子句非常匹配`X: B`. 解决一项义务`X:A1`我们会注意到`X:A2`意味着`X:A1`.

### 确认

*确认*将特性的输出类型参数与在义务中找到的值统一，可能会产生类型错误。

假设我们对`Convert`上一节中的示例：

```rust,ignore
trait Convert<Target> {
    fn convert(&self) -> Target;
}

impl Convert<usize> for isize { ... } // isize -> usize
impl Convert<isize> for usize { ... } // usize -> isize

let x: isize = ...;
let y: char = x.convert(); // NOTE: `y: char` now!
```

确认是由于IMPL指定`Target`将是`usize`但是报告的义务`char`. 因此，选择的结果将是一个错误。

注意，候选IMPL是根据`Self`类型，但确认是基于`Target`类型参数。

### 翻译过程中的选择

如上所述，在类型检查期间，我们不存储特性选择的结果。在trans时，我们重复特性选择，为每个方法调用选择一个特定的impl。在第二个选择中，我们不考虑范围内的任何where子句，因为我们知道每个解决方案都将解析为特定的impl。

一个有趣的变化与嵌套的义务有关。一般来说，在trans中，我们只需要对一项义务做一个“肤浅”的选择。也就是说，我们希望确定哪一个IMPL适用，但我们（还）不需要决定如何选择任何嵌套的义务。尽管如此，我们*做*目前做一个完整的解决方案，这是因为它有时可以通知类型推断的结果。也就是说，对于我们可用的IMPL类型变量，我们没有完全的替换，所以我们必须运行特征选择来解决所有问题。

**托多**：这还说反式？

下面是一个例子：

```rust,ignore
trait Foo { ... }
impl<U, T:Bar<U>> Foo for Vec<T> { ... }

impl Bar<usize> for isize { ... }
```

在一轮浅薄的选择之后`Vec<isize>
: Foo`我们会知道我们想要哪一个IMPL，我们会知道`T=isize`但是我们不知道`U`.  我们必须选择嵌套的义务`isize : Bar<U>`为了找出答案`U=usize`.

只做就好了*同样多*必要时采用嵌套分辨率。不过，目前我们只是做了一个完整的解决方案。
