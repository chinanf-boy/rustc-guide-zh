# 规范化

规范化是**隔离**从上下文推断出的值。它是实现[规范查询][cq]，您可能希望阅读父章节以获得更多上下文。

规范化实际上是基于一个非常简单的概念：每[推理变量](../type-inference.html#vars)总是处于两种状态之一：要么是**未绑定的**，在这种情况下，我们还不知道它是什么类型的，或者它是什么类型的**跳跃**，在这种情况下，我们会这样做。因此，为了将一些包含类型/区域的数据结构t与它的环境隔离开来，我们只需往下走，找到t中出现的未绑定变量；这些变量将被替换为“规范变量”，从零开始，按固定顺序编号（从左到右，大部分情况下，但实际上只要考虑到它就不重要了。T）。

[cq]: ./canonical-queries.html

例如，如果我们有`X = (?T, ?U)`在哪里`?T`和`?U`是不同的、未绑定的推理变量，然后是`X`将是`(?0, ?1)`在哪里`?0`和`?1`代表这些**标准占位符**. 注意类型`Y = (?U, ?T)`也被规范为`(?0, ?1)`. 但类型`Z = (?T, ?T)`将规范化为`(?0, ?0)`（如`(?U, ?U)`）换句话说，推理变量的确切同一性并不重要，除非它们是重复的。

我们使用它来改进缓存，以及在特性解析期间检测循环和其他事情。大致来说，其思想是，如果两个特征查询具有相同的规范形式，那么它们将得到相同的答案。这个答案将用规范变量来表示。（`?0`，`?1`，然后我们可以映射回原始变量。（`?T`，`?U`）

## 规范化查询

要了解它是如何工作的，请假设我们请求解决以下特征查询：`?A: Foo<'static, ?B>`在哪里`?A`和`?B`是未绑定的。此查询包含两个未绑定的变量，但它还包含生存期`'static`. 性状系统通常忽略所有的生命周期，平等对待它们，所以当规范化时，我们会*也*替换任何[自由寿命](../appendix/background.html#free-vs-bound)用一个规范变量（注意`'static`实际上是*自由的*这里是寿命变量。我们不是在整个程序的类型上下文中考虑它，而是只在这个特性引用的上下文中考虑它。从数学上讲，我们并不是在对整个计划进行量化，而是只对这个义务进行量化）。因此，我们得到以下结果：

```text
?0: Foo<'?1, ?2>
```

有时候我们写得不同，比如：

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

这个`for<>`提供了有关中每个规范变量的一些信息。在这种情况下，每个`T`指示类型变量，因此`?0`和`?2`是类型；`L`表示生存期变量，因此`?1`是一生。这个`canonicalize`方法*也*还给A`CanonicalVarValues`用每个规范化变量的“原始值”数组ov：

```text
[?A, 'static, ?B]
```

稍后处理查询响应时，我们将需要这个向量ov。

## 执行查询

一旦我们构建了规范查询，我们就可以尝试解决它。为此，我们将最终创建一个新的推理上下文，并**例示**该上下文中的规范查询。其思想是，我们从包含每个规范变量的新推理变量（适当类型）的规范形式创建一个替换s。因此，对于我们的示例查询：

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

替代S可能是：

```text
S = [?A, '?B, ?C]
```

然后我们可以替换绑定的规范变量（`?0`等）使用这些推理变量，生成以下完全实例化的查询：

```text
?A: Foo<'?B, ?C>
```

不过，记住这个替换！我们以后需要它。

好了，现在我们有了一个新的推理上下文和一个实例化的查询，我们可以继续并尝试解决它。特性解算器本身在[另一节](./slg.html)，但足以说明它将计算[确定性值][cqqr]（`Proven`或`Ambiguous`）对我们创建的推理变量有副作用。例如，如果只有一个impl`Foo`，像这样：

[cqqr]: ./canonical-queries.html#query-response

```rust,ignore
impl<'a, X> Foo<'a, X> for Vec<X>
where X: 'a
{ ... }
```

那么我们最终可能会得到`Proven`以及创建新的推理变量`'?D`和`?E`（表示IMPL上的参数）并统一如下：

-   `'?B = '?D`
-   `?A = Vec<?E>`
-   `?C = ?E`

我们还将累积区域约束`?E: '?D`，由于WHERE子句。

为了创建最终的查询结果，我们必须将这些值从查询的推理上下文中“提升”出来，并将其重新应用到原始推理上下文中。我们这样做**重新应用规范化**但对**查询结果**.

## 规范化查询结果

正如在[父节][cqqr]大多数特征查询的结果都是“确定值”`certainty`，结果替换`var_values`以及一些区域约束。为了创建这个，我们最终会重新使用我们在第一次实例化查询时创建的替换。为了刷新您的记忆，我们有一个查询

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

为此我们做了一个替换：

```text
S = [?A, '?B, ?C]
```

然后我们做了一些工作，将这些变量与其他事物统一起来。如果我们用最新的结果“刷新”，我们会得到：

```text
S = [Vec<?E>, '?D, ?E]
```

这些正是我们原始查询中三个输入变量的新值。注意，尽管它们包含一些新的变量（比如`?E`）我们可以通过再次圣典化来让它们消失！但是，我们不仅规范化了S，还规范化了整个查询响应QR：

```text
QR = {
    certainty: Proven,             // or whatever
    var_values: [Vec<?E>, '?D, ?E] // this is S
    region_constraints: [?E: '?D], // from the impl
    value: (),                     // for our purposes, just (), but
                                   // in some cases this might have
                                   // a type or other info
}
```

结果如下：

```text
Canonical(QR) = for<T, L> {
    certainty: Proven,
    var_values: [Vec<?0>, '?1, ?2]
    region_constraints: [?2: '?1],
    value: (),
}
```

（一个微妙的点：当我们规范化查询时**结果**我们终生不享受任何特殊待遇。注意这两个引用`'?D`例如，被转换成相同的规范变量（`?1`）这与原始查询相反，我们将每个自由生命周期规范化为一个新的规范变量。）

现在，这个结果必须在需要的每个上下文中重新应用。

## 处理规范化查询结果

在前一节中，我们生成了规范查询结果。我们现在必须将这个结果应用到我们的原始上下文中。如果您还记得，我们在一开始就试图证明这个问题：

```text
?A: Foo<'static, ?B>
```

我们将其规范化为：

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

现在我们得到了一个规范的反应：

```text
for<T, L> {
    certainty: Proven,
    var_values: [Vec<?0>, '?1, ?2]
    region_constraints: [?2: '?1],
    value: (),
}
```

我们现在想将这个响应应用到我们的上下文中。从概念上讲，我们是如何做到这一点的：（a）用一个新的推理变量实例化结果中的每个规范变量，（b）将结果中的值与原始值统一起来，然后（c）为以后记录区域约束。执行步骤（a）会导致

```text
{
      certainty: Proven,
      var_values: [Vec<?C>, '?D, ?C]
                       ^^   ^^^ fresh inference variables
      region_constraints: [?C: '?D],
      value: (),
}
```

步骤（b）将统一：

```text
?A with Vec<?C>
'static with '?D
?B with ?C
```

最后是区域约束`?C: 'static`会被记录下来以便日后核查。

（我们*事实上*do是一个适度优化的变量：我们不是急于用变量实例化结果中的所有规范值，而是遍历值的向量，寻找值只是规范变量的情况。在我们的例子中，`values[2]`是`?C`这意味着我们可以推断`?C := ?B and`“？D: =“静态”。这给了我们一组局部的值。任何我们找不到值的东西，我们都会创建一个推理变量。）
