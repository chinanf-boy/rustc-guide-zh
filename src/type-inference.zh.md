# 类型推断

类型推断是自动检测表达式类型的过程。

它允许rust使用较少或不使用类型注释，从而使用户更容易：

```rust,ignore
fn main() {
    let mut things = vec![];
    things.push("thing")
}
```

这里是`things`是*推理的*成为`&str`因为这就是我们所追求的价值`things`.

类型推断基于标准的Hindley-Milner（HM）类型推断算法，但以各种方式扩展，以适应子类型、区域推断和更高级别的类型。

## 术语注释

我们用符号`?T`指推理变量，也叫存在变量。

我们可以交替使用“区域”和“寿命”这两个术语。两者均指`'a`在里面`&'a T`.

术语“绑定区域”是指在函数签名中绑定的区域，例如`'a`在里面`for<'a> fn(&'a u32)`. 如果一个区域没有绑定，它就是“自由”的。

## 创建推理上下文

您可以通过执行以下操作来创建和“输入”推理上下文：

```rust,ignore
tcx.infer_ctxt().enter(|infcx| {
    // Use the inference context `infcx` here.
})
```

每个推理上下文都创建了一个短期的类型竞技场来存储新类型和它将创建的内容，如[章节关于`ty`模块][ty-ch]. 这个竞技场是由`enter`函数，并在返回后释放。

[ty-ch]: ty.html

在封闭区内，`infcx`有类型`InferCtxt<'cx, 'gcx, 'tcx>`一些新鲜的`'cx`和`'tcx`–后者对应于这个临时竞技场的寿命，以及`'cx`是生命的`InferCtxt`本身。（再次，看到[`ty`章][ty-ch]有关此设置的详细信息。）

这个`tcx.infer_ctxt`方法实际上返回一个生成器，这意味着在`infcx`创建。见`InferCtxtBuilder`更多信息。

<a name="vars"></a>

## 推理变量

推理上下文的主要目的是容纳**推理变量**–这些代表的类型或区域的精确值尚不清楚，但在执行类型检查时会被发现。

如果您熟悉H-M类型系统统一的基本思想，或者像Prolog这样的逻辑语言，那么这是相同的概念。如果不是，您可能想阅读一个关于H-M类型推断如何工作的教程，或者这个博客文章[粉笔工程的统一].

[unification in the chalk project]: http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/

综上所述，从本文开始，推理上下文存储了四种推理变量：

-   类型变量有三种：
    -   常规类型变量（最常见）。这些可以与任何类型统一。
    -   整型变量，它只能与整型统一，并由整型文字表达式产生，如`22`.
    -   float类型变量，它只能与float类型统一，并且由float文本表达式（如`22.0`.
-   区域变量，代表生命周期，并出现在各地。

所有类型变量的工作方式基本相同：您可以创建一个新的类型变量，得到的是`Ty<'tcx>`表示未解析的类型`?T`. 然后，您可以应用推理程序支持的各种操作，例如相等或子类型，它可能**实例化**（或）**绑定**）`?T`结果得到一个特定的值。

区域变量的工作方式有些不同，下面将在单独的部分中进行描述。

## 强制相等/子类型

在类型推断器中可以执行的最基本的操作是**平等**，强制两种类型`T`和`U`保持不变。建议添加相等约束的方法是使用`at`方法，大致如下：

```rust,ignore
infcx.at(...).eq(t, u);
```

第一`at()`调用提供了一点上下文，即为什么要进行这种统一，在什么环境中，以及`eq`方法执行实际的相等约束。

当你把事物相等时，你强迫它们完全相等。相等返回`InferResult`–如果它返回`Err(err)`，然后相等失败，封闭`TypeError`会告诉你出了什么问题。

成功案例可能更有趣。“主要”返回类型`eq`是`()`—也就是说，当它成功时，它不会返回任何特定兴趣的值。相反，它是为约束类型变量等的副作用而执行的。但是，实际返回类型不是`()`但更确切地说`InferOk<()>`. 这个`InferOk`类型用于承担额外的特性义务——您的工作是确保这些特性得到满足（通常是在实现上下文中注册它们）。见[特质章]关于这方面的更多背景。

[trait chapter]: traits/resolution.html

同样，您可以通过`infcx.at(..).sub(..)`. 上述基本概念同样适用。

## “尝试”平等

有时候你想知道是不是*可能的*使两种类型相等而不出错。你可以用`infcx.can_eq`（或）`infcx.can_sub`用于子类型）。如果这种回报`Ok`因此，平等是可能的——但在所有情况下，任何副作用都是相反的。

不过，要知道，这些方法的成败总是**模区域**.也就是说，有两种类型`&'a u32`和`&'b u32`会回来的`Ok`对于`can_eq`，即使`'a != 'b`.这源于我们如何解决区域约束的“两阶段”性质。

## 快照

如前一节所述`can_eq`通常，能够执行一系列操作，然后回滚它们的副作用是有用的。这样做的原因有很多：其中之一是能够回溯，在确定要走哪条路之前尝试多种可能性。另一个是为了确保一系列较小的变化是原子性的或根本不发生的。

为了实现这一点，推理上下文支持`snapshot`方法。当您调用它时，它将开始记录您执行的操作所发生的更改。完成后，可以调用`rollback_to`，这将撤消这些更改，或者`confirm`这将是永久性的。只要遵循类似堆栈的规则，就可以嵌套快照。

与其直接使用快照，不如使用`commit_if_ok`或`probe`它封装了更高级的模式。

## 子类型义务

值得讨论的一件事是子类型的义务。当您强制两种类型成为子类型时，例如`?T <: i32`我们通常可以将这些转换为相等约束。这源于Rust有限的子类型概念：因此，在上面的例子中，`?T <: i32`等于`?T = i32`.

但是，在某些情况下，我们必须更加小心。例如，当涉及区域时。所以如果你有`?T <: &'a i32`我们要做的是首先“概括”`&'a i32`转换为具有区域变量的类型：`&'?b i32`，然后统一`?T`带着那个（`?T = &'?b i32`）然后我们将这个新变量与原始界限联系起来：

```text
&'?b i32 <: &'a i32
```

这将导致区域约束（见下文）`'?b: 'a`.

最后一个有趣的例子是关联两个未绑定的类型变量，比如`?T <: ?U`.  在这种情况下，我们不能取得进展，所以我们把一项义务排队`Subtype(?T, ?U)`并通过返回`InferOk`机制。当更多有关`?T`或`?U`是众所周知的。

## 区域约束

区域的推断与类型有些不同。我们不是急于统一事物，我们只是在前进中收集约束条件，但（几乎）没有试图解决地区问题。这些约束的形式是“异常值”约束：

```text
'a: 'b
```

实际上，代码倾向于将它们视为一个次区域关系，但这是相同的想法：

```text
'b <= 'a
```

（存在各种其他类型的约束，例如“verifys”；请参见`region_constraints`详细信息模块。）

有一种情况是，我们进行了一定程度的渴望统一。如果两个区域之间有相等约束

```text
'a = 'b
```

我们将在统一表中记录这一事实。然后你可以使用`opportunistic_resolve_var`皈依`'b`到`'a`（反之亦然）。有时需要这样做来确保定点算法的终止。

## 提取区域约束

最终，区域约束只在类型检查的最后一步解决，一旦所有其他约束都已知。目前有两种方法可以解决区域约束：词汇约束和非词汇约束。最终只有一个。

解决**词汇的**区域约束，调用`resolve_regions_and_report_errors`.  这将“关闭”区域约束过程并调用`lexical_region_resolve`代码。一旦这样做了，任何进一步的等同或创建子类型关系的尝试都将产生一个冰。

非词汇区域约束不在推理上下文中处理。相反，NLL解算器（实际上是mir类型检查器）调用`take_and_reset_region_constraints`定期地。这将从区域解算器中提取所有的异常值约束，但保持变量集的完整性。这是用来*只是*由于NLL解算器不仅需要知道，还需要知道程序中某个特定点产生的区域约束。*什么*区域是次区域，但*在哪里？*. 最后，NLL解算器调用`take_region_var_origins`以与正常求解相同的方式“关闭”区域约束过程。

## 词汇区域分辨率

词法区域解析是通过最初将每个区域变量赋给空值来完成的。然后，我们重复处理每个异常值约束，不断增加区域变量，直到达到一个固定点。区域变量可以使用区域格上的最小上界关系以相当直接的方式增长。
