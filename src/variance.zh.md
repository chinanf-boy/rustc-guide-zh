# 类型和寿命参数的方差

有关方差的更一般背景，请参见[背景]附录。

[background]: ./appendix/background.html

在类型检查期间，我们必须推断类型和生存期参数的方差。算法取自本文第4节。[“驯服通配符：结合定义和使用站点差异”][pldi11]发表于PLDI'11，作者为Altidor等人，以下简称本文。

[pldi11]: https://people.cs.umass.edu/~yannis/variance-extended2011.pdf

这个推论是明确设计的*不*考虑代码中类型的使用。确定类型上定义的类型参数的方差`X`我们只考虑类型的定义`X`以及它所引用的任何类型的定义。

我们只推断在上找到的类型参数的方差*数据类型*像结构和枚举。在这些情况下，对于方差的含义有一个相当直接的解释。类型或生存期参数的方差定义了`T<A>`是一个亚型`T<B>`（RESP）`T<'a>`和`T<'b>`）基于`A`和`B`（RESP）`'a`和`'b`）

我们不推断在特征、函数或impl上发现的类型参数的方差。特征参数的变化确实有意义（我们过去常常计算它），但实际上它在意义上相当微妙，在实践中没有那么有用，所以我们去掉了它。见[补遗]了解一些细节。另一方面，函数/impl参数上的差异是没有意义的，因为这些参数被实例化然后被遗忘，它们不存在于类型或编译的副产品中。

[addendum]: #addendum

> **记数法**
>
> 我们在本章中使用了论文的注释：
>
> -   `+`是*协方差*.
> -   `-`是*逆变*.
> -   `*`是*双方差*.
> -   `o`是*不变性*.

## 算法

基本的想法很简单。我们迭代定义的类型，并针对每种类型参数的使用`X`，累积一个约束，指示`X`必须对该使用网站的差异有效。然后我们迭代地改进`X`直到满足所有约束。有*总是*一个解决方案，因为在限制条件下，我们可以声明所有类型参数都是不变的，并且所有约束都将得到满足。

作为一个简单的例子，考虑：

```rust,ignore
enum Option<A> { Some(A), None }
enum OptionalFn<B> { Some(|B|), None }
enum OptionalMap<C> { Some(|C| -> C), None }
```

在这里，我们将生成约束：

```text
1. V(A) <= +
2. V(B) <= -
3. V(C) <= +
4. V(C) <= -
```

这表明：（1）a的方差至多是协变的；（2）b的方差至多是反变的；（3，4）c的方差至多是协变的。*和*逆变的所有这些结果都基于如下定义的方差格：

```text
   *      Top (bivariant)
-     +
   o      Bottom (invariant)
```

基于这个格子，解`V(A)=+`，`V(B)=-`，`V(C)=o`是最佳解决方案。注意，总是有一个简单的解决方案声明所有变量都是不变的。

您可能想知道为什么需要定点迭代。原因是一个使用站点的方差本身可能是其他类型参数方差的函数。一般来说，我们的约束形式如下：

```text
V(X) <= Term
Term := + | - | * | o | V(X) | Term x Term
```

这里是符号`V(X)`指示类型/区域参数的差异`X`关于它的定义类。`Term x Term`表示本文中定义的“方差变换”：

> 如果类型变量的方差`X`在类型表达式中`E`是`V2`以及定义地点的差异[相应的]类的类型参数`C`是`V1`，然后是方差`X`在类型表达式中`C<E>`是`V3 = V1.xform(V2)`.

## 约束条件

如果我有一个带有where子句的结构或枚举：

```rust,ignore
struct Foo<T: Bar> { ... }
```

你可能想知道`T`关于`Bar`影响方差`T`关于`Foo`. 我要求不。理由：假设`T`相对于`Bar`但是关于`Foo`.然后我们有一个`Foo<X>`向上投射到`Foo<Y>`，在哪里`X <: Y`.然而，当`X : Bar`，请`Y : Bar`不能保持。在这种情况下，向上转换将是非法的，但不是因为方差失败，而是因为目标类型`Foo<Y>`只是形式不太好。基本上，在考虑方差之前，我们假设所有涉及的类型都具有良好的形式性。

### 依赖关系图管理

因为方差是一个完整的箱子推理，如果我们不小心，它的依赖关系图可能会变得非常混乱。为了解决这个问题，我们将重构为两个查询：

-   `crate_variances`计算当前箱子中所有项目的差异。
-   `variances_of`访问单个读数的方差；它通过请求`crate_variances`提取相关数据。

如果你限制自己阅读`variances_of`，您的代码将仅依赖于该特定项的推理。

最终，此设置依赖于[红绿算法][rga]. 尤其是，每个差异查询有效地依赖于整个箱子中的所有类型定义（通过`crate_variances`，但由于大多数变化不会导致方差推断实际结果的变化，因此`variances_of`重新评估后，查询将被视为绿色。

[rga]: ./queries/incremental-compilation.html

<a name="addendum"></a>

## 附录：特征方差

如上所述，我们过去允许性状的变异。这是根据方法签名中的特征类型参数的外观计算的，用于表示特征对象中vtables的兼容性（以及特征边界中的“虚拟”vtables或字典）。一个复杂的问题是，相关类型的差异不太明显，因为它们可以被投影出来并用于无数的用途，所以不清楚何时允许`X<A>::Bar`改变（或真正意义上的改变）。此外（如下所述），任何具有关联类型的特性的所有输入都必须是不变的，从而限制了适用性。最后，注释（`MarkerTrait`，`PhantomFn`）需要确保所有的特征类型参数都有一个方差，这会让人感到困惑和烦人，但效果甚微。

为了历史参考，我将保留一些文本，指出如何解释方差和特征匹配。

### 方差和对象类型

就像结构和枚举一样，我们可以决定两个对象类型之间的子类型关系。`&Trait<A>`和`&Trait<B>`基于`A`和`B`. 注意，对于对象类型，我们忽略`Self`类型参数–它是未知的，动态调度的性质确保我们总是调用一个期望适当的函数`Self`类型。但是，我们必须小心处理其他类型参数，否则我们可能最终调用一个期望一种类型但提供另一种类型的函数。

为了理解我的意思，考虑这样一个特征：

```rust
trait ConvertTo<A> {
    fn convertTo(&self) -> A;
}
```

直觉上，如果我们有一个物体`O=&ConvertTo<Object>`另一个`S=&ConvertTo<String>`然后`S <: O`因为`String <: Object`（假定Java类的“string”和“对象”类型，我的示例用于子类型化）。实际的算法是比较（显式）类型参数对的方差：这里，类型参数A是协变的（它只出现在返回位置），因此我们要求`String <: Object`.

您会注意到，尽管我们没有考虑对（隐式）的绑定`Self`类型参数：实际上，它是未知的，所以很好。我们可以忽略该参数的原因正是因为在调用发生之前我们不需要知道它的值，而此时（如您所说），虚拟调度的动态特性意味着我们运行的代码对于任何值都是正确的。`Self`恰好绑定到了我们调用其方法的特定对象。`Self`因此不同于`A`，因为调用方要求`A`已知以了解方法的返回类型`convertTo()`. （顺便说一句，我们有规则阻止方法`Self`出现在接收点位置之外，无法通过对象调用。）

### 特征方差和vtable分辨率

但是特征不仅仅用于物体。它们也用于决定给定的impl是否满足给定的特征约束。要在这里设置场景，假设我有一个功能：

```rust,ignore
fn convertAll<A,T:ConvertTo<A>>(v: &[T]) { ... }
```

现在假设我有一个`ConvertTo`对于`Object`：

```rust,ignore
impl ConvertTo<i32> for Object { ... }
```

我想打电话`convertAll`在字符串数组上。再进一步假设，无论出于什么原因，我特别提供`String`对于类型参数`T`：

```rust,ignore
let mut vector = vec!["string", ...];
convertAll::<i32, String>(vector);
```

这合法吗？换一种说法，我们可以应用`impl`对于`Object`向类型`String`？答案是肯定的，但要想知道为什么我们必须扩展将要发生的事情：

-   `convertAll`将创建指向矢量中某个条目的指针，该条目将具有类型`&String`
-   然后它将调用`convertTo()`用于对象的。这是那种`fn(self: &Object) -> i32`.

    可以为提供一个值`self`类型的`&String`因为`&String <: &Object`.

好吧，直观地说，我们希望这是合法的，所以让我们把它带回方差，看看我们是否在计算正确的结果。我们必须首先弄清楚如何表达这个问题“是一个`Object,i32`在impl用于`String,i32`是吗？”

也许考虑一个通过类型类实现的字典是很有帮助的。在那种情况下，`convertAll()`采用表示IMPL的隐式参数。简而言之，我们*有*类型的IMPL：

```text
V_O = ConvertTo<i32> for Object
```

函数原型需要一个impl类型：

```text
V_S = ConvertTo<i32> for String
```

与任何参数一样，如果给定值的类型（`V_O`）是所需类型的子类型（`V_S`）所以是`V_O <: V_S`？答案将取决于各种参数的方差。在这种情况下，因为`Self`参数是反变的，并且`A`是协变的，意思是：

```text
V_O <: V_S iff
    i32 <: i32
    String <: Object
```

这些条件都满足了，所以我们很高兴。

### 差异和关联类型

具有相关类型的特征（或者至少是投影表达式）必须对所有输入保持不变。要了解这为什么有意义，请考虑特征引用的子类型意味着什么：

```text
<T as Trait> <: <U as Trait>
```

意思是如果我知道的话`T as Trait`我也知道`U as
Trait`. 此外，如果你把它看作字典传递样式，它意味着`<T as Trait>`在字典用于`<U as Trait>`是意料之中的事。

问题是，当您可以从`<T as
Trait>`，与从中投影出的类型的关系`<U as Trait>`完全未知，除非`T==U`（更多详情请参见21726）。制作`Trait`不变量确保这是真的。

另一个相关的原因是，如果我们不使关联类型的特征不变，那么投影就不再是具有单个结果的函数。考虑：

```rust,ignore
trait Identity { type Out; fn foo(&self); }
impl<T> Identity for T { type Out = T; ... }
```

如果我有`<&'static () as Identity>::Out`，这可以有效地导出为`&'a ()`对于任何`'a`：

```text
<&'a () as Identity> <: <&'static () as Identity>
if &'static () < : &'a ()   -- Identity is contravariant in Self
if 'static : 'a             -- Subtyping rules for relations
```

这个变化意味着`<'static () as Identity>::Out`总是`&'static ()`（然后可能会向上投射到`'a ()`，分别）。这对解决21750问题很有帮助。
