# 名称解析

名称解析是一个两阶段的过程。在宏扩展过程中的第一个阶段，我们构建了一个模块树并解析导入。宏扩展和名称解析通过`Resolver`性状，定义于`libsyntax`.

第二阶段的输入是语法树，通过解析输入文件和扩展宏生成。此阶段生成从源中的所有名称到引入名称的相关位置的链接。它还生成有用的错误消息，如打字建议、导入的特性或未使用项目的lints。

第二阶段的成功运行（`Resolver::resolve_crate`）创建一种索引，编译的其余部分可以使用该索引询问有关当前名称的信息（通过`hir::lowering::Resolver`接口）。

名称解析位于`librustc_resolve`板条箱，里面有肉`lib.rs`以及其他模块中的一些辅助程序或符号类型特定逻辑。

## 命名空间

不同类型的符号存在于不同的名称空间中，例如，类型不会与变量冲突。这通常不会发生，因为变量以小写字母开头，而类型以大写字母开头，但这只是一种约定。这是将要编译（带有警告的）的法律信任代码：

```rust
type x = u32;
let x: x = 1;
let y: x = 2; // See? x is still a type here.
```

为了解决这个问题，以及使用这些名称空间的稍微不同的作用域规则，解析器将它们分开，并为它们构建单独的结构。

换句话说，当代码谈到名称空间时，并不意味着模块层次结构，而是类型、值和宏。

## 范围和肋骨

名称仅在源代码的特定区域中可见。这形成了一个层次结构，但不一定是一个简单的结构如果一个作用域是另一个作用域的一部分，并不意味着在外部可见的名称在内部也可见，或者它指的是同一事物。

为了解决这个问题，编译器引入了肋骨的概念。这是范围的抽象。每次可见名称集可能发生更改时，都会将新的肋骨推到堆栈上。可能发生这种情况的地方包括：

-   明显的地方花括号包围一个块、函数边界、模块。
-   引入let绑定这可能会隐藏同名的另一个绑定。
-   宏观扩展边界以应对宏观卫生。

在搜索名称时，肋骨的堆栈从最里面向外遍历。这有助于找到名称最接近的含义（不被其他任何东西遮蔽的名称）。到外部RIB的转换还可以更改规则哪些名称可用如果有嵌套函数（而不是闭包），则内部函数无法访问外部函数的参数和本地绑定，即使它们应该由普通范围规则可见。一个例子：

```rust
fn do_something<T: Default>(val: T) { // <- New rib in both types and values (1)
    // `val` is accessible, as is the helper function
    // `T` is accessible
    let helper = || { // New rib on `helper` (2) and another on the block (3)
        // `val` is accessible here
    }; // End of (3)
    // `val` is accessible, `helper` variable shadows `helper` function
    fn helper() { // <- New rib in both types and values (4)
        // `val` is not accessible here, (4) is not transparent for locals)
        // `T` is not accessible here
    } // End of (4)
    let val = T::default(); // New rib (5)
    // `val` is the variable, not the parameter here
} // End of (5), (2) and (1)
```

因为不同名称空间的规则有点不同，所以每个名称空间都有自己独立的肋骨堆栈，它们是平行于其他名称空间构建的。此外，还有一个用于本地标签的肋骨堆栈（例如循环或块的名称），它本身不是完整的名称空间。

## 总体战略

为了执行整个板条箱的名称解析，从上到下遍历语法树，并解析每个遇到的名称。这适用于大多数类型的名称，因为在使用名称时，它已经引入到了RIB层次结构中。

有一些例外。项目有点棘手，因为它们甚至可以在遇到之前使用因此，每个块都需要首先扫描项目以填充其肋骨。

其他的，甚至更麻烦的，是需要递归定点解析的导入，以及需要在处理其余代码之前解决和扩展的宏。

因此，分辨率分多个阶段执行。

## TODO：

这是第一次学习代码的结果。它肯定是不完整的，不够详细。在某些地方也可能不准确。尽管如此，它可能还是提供了有用的第一个指南来说明那里发生了什么。

-   它究竟链接到什么，如何通过以下编译阶段发布和使用？
-   谁叫它，它是如何实际使用的。
-   它是一个通过，然后只使用结果，还是可以递增计算（例如，对于RLS）？
-   总体战略描述有点模糊。
-   名字在哪`Rib`来自何方？
-   这个东西是否有自己的测试，或者只是作为一些E2E测试的一部分进行测试？
