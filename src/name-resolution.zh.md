# 名称解析

名称解析是有两阶段的过程。第一个阶段，处于宏扩展过程中，我们构建了一个模块树，并解析导入。宏扩展和名称解析通过`Resolver`trait(定义于`libsyntax`)，相互交流。

第二阶段的输入是语法树，通过解析输入文件和扩展宏。此阶段生成从源中的所有名称，到引入名称相关位置的链接。它还生成有用的错误消息，如类型建议、导入的 trait 或未使用的 lints。

第二阶段的成功运行（`Resolver::resolve_crate`）创建一种索引，编译的其余部分可以使用该索引，询问有关当前名称的信息（通过`hir::lowering::Resolver`接口）。

名称解析位于`librustc_resolve`箱子，在`lib.rs`中有主食，以及其他模块中的一些甜品(辅助)程序或符号类型特定逻辑。

## 命名空间

不同类型的符号，存在于不同的命名空间中，例如，类型不会与变量冲突。这通常不会发生，因为变量以小写字母开头，而类型以大写字母开头，但这只是一种编码风格。这是将要编译（带有警告的）的 Rust 合法代码：

```rust
type x = u32;
let x: x = 1;
let y: x = 2; // 看到没有? x 在这里，仍作为一个类型
```

为了解决这个问题，会对这些命名空间，有稍微不同的作用域规则。解析器会将它们分开，并为它们构建单独的结构。

换句话说，当代码谈到命名空间时，并不代指模块层次结构，而是类型、值和宏。

## 作用域和 Ribs

名称仅在源代码的特定区域中可见。这形成了一个层次结构，但不一定是一个简单的结构 —— 如果一个作用域是另一个作用域的一部分，并不意味着，外部可见的名称，在内部也可见，或指的是同一事物。

为了解决这个问题，编译器引入了 Ribs 的概念。这是作用域的抽象。每次可见名称的集合可能发生更改时，都会将新的 Ribs 推到一个栈上。可能发生这种情况的地方包括：

- 明显之处 —— 用花括号包围一个代码块、函数边界、模块。
- 引入 let 绑定 —— 这可能会隐藏同名变量的另一个绑定。
- 宏扩展边界 —— 应对宏的卫生安全(hygiene)。

在搜索名称时，ribs 的堆栈，从最里面向外遍历。这有助于找到名称最接近的含义（不被其他任何东西遮蔽的名称）。到了外部 rib 的转换操作，还可能更改哪些名称可用的规则 —— 如果有嵌套函数（而不是闭包），则内部函数，无法访问外部函数的参数和本地绑定，即使在正常作用域规则下，他们应该是可见的。一个例子：

```rust
fn do_something<T: Default>(val: T) { // <- 新的 rib 是 types 和 values 两者 (1)
    // `val` 可访问的, as is the helper function
    // `T` 可访问的
    let helper = || { // 新的 rib 在 `helper` 上 (2) 和 另一个 在代码块上 (3)
        // `val` 这里可访问的
    }; //  (3)结束
    // `val` 可访问的, `helper` 变量盖住了 `helper` 函数
    fn helper() { // <- 新的 rib 是 types 和 values 两者 (4)
        // `val` 在这里不可访问了, (4) 对局部变量来说，并不清晰)
        // `T` 在这里不可访问了
    } //  (4) 结束
    let val = T::default(); // 新 rib (5)
    // `val` 这里是变量, 不是参数
} // 结束 (5), (2) 和 (1)
```

因为不同命名空间的规则有点不同，所以每个命名空间都有自己独立的 Ribs 堆栈，它们是平行于其他命名空间构建的。此外，还有一个用于本地标签的 Ribs 堆栈（例如：循环或代码块的名称），它本身不是完整的命名空间。

## 总体战略

为了执行整个箱子的名称解析，从上到下遍历语法树，并解析每个遇到的名称。这适用于大多数类型的名称，因为在使用名称时，它已经引入到了 rib 层次结构中。

有一些例外。项有点棘手，因为它们甚至可以在遇到之前，使用 —— 因此，每个代码块都需要先扫描自身的项，以填充其 Ribs。

其他的，甚至更麻烦的问题，是需要递归定点解析的导入，以及需要在处理其余代码之前解决和扩展的宏。

因此，名称解析分多个阶段执行。

## TODO：

这是第一次学习代码的结果。它肯定是不完整的，不够详细。在某些地方也可能不准确。尽管如此，它恰巧提供了，第一个有用的指南，来说明那里发生了什么。

- 它究竟链接到什么，如何通过以下编译的阶段，来发布和使用？
- 谁调用它，它是如何实际使用的。
- 它是一个通过参数，然后只使用结果，还是可以增量计算（例如，对于 RLS）？
- 总体战略描述有点模糊。
- 名字`Rib`来自何方？
- 这个东西是否有自己的测试，或者只是作为一些 E2E 测试的一部分，进行测试？
