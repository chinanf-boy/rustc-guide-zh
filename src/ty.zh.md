# 这个`ty`模块：描述类型

这个`ty`模块定义了 Rust 编译器，如何在内部描述类型。它还定义了这个*类型上下文（typing context）*（`tcx`或`TyCtxt`) —— 编译器的中心数据结构。

## tcx 及其如何使用生命周期

这个`tcx`（“类型上下文”）是编译器的中心数据结构，是用于执行所有查询方式的上下文。结构体`TyCtxt`定义了一个，到共享上下文的引用：

```rust,ignore
tcx: TyCtxt<'a, 'gcx, 'tcx>
//          --  ----  ----
//          |   |     |
//          |   |     innermost(内部) arenas 生命周期 (如果有的话)
//          |   "global(全局) arenas" 生命周期
//          引用的生命周期
```

如你所见，`TyCtxt`类型需要三个生命周期参数。这些生命周期可能是弄懂 tcx 的最大阻碍。在 Rust 编译期间，我们将大部分内存分配到**arenas**，具体可以说是，能一次释放所有内存的'池'。当你看到像`'tcx`或`'gcx`，这样一个带着一个生命周期的引用，您就知道它指的是 arenas 分配的数据（或与 arenas 一样长命的数据，无论哪种方式）。

我们使用两种不同层次的 arenas。外层是“全局舞台”。这个舞台会一直在整个编译过程：所以只有在编译基本结束后（实际上，当我们转向执行 LLVM 时），您在其中分配的任何内容才会被释放。

为了减少峰值内存的使用，当我们进行类型推断时，我们还使用了内部层的 arenas。一旦类型推断结束，这些 arenas 就会被丢弃。这样做是因为类型推断过程，会生成许多在其完成后，不再感兴趣的“可扔”类型，因此保留这些分配内存是浪费的。

通常，我们希望在类型推断期间，明确断言的代码不发生。在这种情况下，因没有“局部”arenas，您可以访问的所有类型，都在全局 arenas 中分配。为了说明这一点，我们的想法是给`TyCtxt`的`'gcx`和`'tcx`参数，配同一个生命周期。只是有点困惑，这个`'tcx`名字的使用，往往是这种情况下。下面是一个例子：

```rust,ignore
fn not_in_inference<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {
    //                                        ----  ----
    //                                        在这里断言，使用同一生命周期
    //                                        ，这样的话，
    //                                        通过此引用，可访问的内部arena *就是* 全局 arena
}
```

相反，如果我们想在类型推断期间，代码发生，那么您需要声明一个清晰的`'gcx`和`'tcx`生命周期参数：

```rust,ignore
fn maybe_in_inference<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) {
    //                                                ----  ----
    //                                        在这里使用不同的生命周期，这意味着
    //                                        内部 arena *可能* 区别于
    //                                        全局  arena (但不一定是)。
}
```

### 分配和使用类型

Rust 类型是用，定义在`ty`模块的`Ty<'tcx>`，来描述的（不要和[the HIR]的`Ty`结构搞混了）。实际上，这是一个简单类型别名，对应的是，带有`'tcx`生命周期的引用：

```rust,ignore
pub type Ty<'tcx> = &'tcx TyS<'tcx>;
```

[the hir]: ./hir.zh.html

你基本上可以忽略`TyS`结构 —— 因基本上，你永远不会明确地访问它。我们总是用`Ty<'tcx>`别名 —— 我想唯一的例外是，定义类型的 inherent 方法时。`TyS`的实例仅在一个 rustc arenas 中分配（从未在栈上分配）。

对类型的一个常见操作是，**match** 和 看看它们是什么类型的。这是通过`match ty.sty`完成的，有点像这样：

```rust,ignore
fn test_type<'tcx>(ty: Ty<'tcx>) {
    match ty.sty {
        ty::TyArray(elem_ty, len) => { ... }
        ...
    }
}
```

这个`sty`字段（我不清楚这个名称的来源；可能是结构类型？）属于类型`TyKind<'tcx>`这是一个枚举，定义编译器中所有不同类型的类型(集合)。

> 注意，在类型推断过程中，检查类型上的`sty`字段可能有风险，因为可能需要考虑推断变量和其他项，或者有时，还不知道类型，稍后会知道）。

要分配一个新类型，可以使用在`tcx`上定义的`mk_`方法。这些方法的名称，主要对应于各种类型的变体。例如：

```rust,ignore
let array_ty = tcx.mk_array(elem_ty, len * 2);
```

这些方法都返回`Ty<'tcx>` —— 请注意，返回的生命周期是内部 arenas 的，所以`tcx`有权访问。事实上，类型总是被规范化和保留性的（因此我们从不分配两次完全相同的类型），并且如果它们可以的话，总选择在最外层的 arena ，去分配它们。（因此，如果它们不包含任何推断变量或其他“临时”类型，它们将在全局 arena 中分配）。然而，生命周期`'tcx`总是一个更为安全的值，而这就是你得到的。

> 注意。由于类型是保留性的，因此有可能使用`==`，来比较他们是否有效性相等 —— 但是，除非您碰巧在哈希和查找重复项，否则结果几乎都不是您想要的。这是因为通常在 Rust 中，有多种方法来表示同一类型，特别是在涉及到类型推断时。如果要测试类型相等性，您可能需要开始研究，推断代码是如何正确运行的。

您还可以通过访问`tcx.types.bool`，`tcx.types.char`等，在`tcx`，找到不同的常见类型，(查看`CommonTypes`，了解更多）。

### 类型之外：其他 arenas 分配数据结构

除了类型之外，还可以分配，许多其他 arenas 分配数据结构，这些数据结构可以在本 ty 模块中找到。以下是几个例子：

- [`Substs`][subst]，用`mk_substs`分配 —— 存有类型的一个切片，通常用于指定要替代泛型的值（例如：`HashMap<i32, u32>`将表示为一个`&'tcx [tcx.types.i32, tcx.types.u32]`切片）
- `TraitRef`，通常用值来传递 —— 为一个**trait 引用**，其包括对 trait 及其各种类型参数（包括`Self`）的引用, 像是`i32: Display`（在这里，def-id 会是指向`Display`trait，和 substs 会包含`i32`）。
- `Predicate`定义了些， trait 系统必须证明的东西（参见`traits`模块）。

[subst]: ./kinds.zh.html#subst

### Import 编码风格

虽然没有硬性规定，但是`ty`模块的使用方式如下：

```rust,ignore
use ty::{self, Ty, TyCtxt};
```

特别是，由于很常见，`Ty`和`TyCtxt`类型会直接导入。其他类型通常用`ty::`前缀，显式引用（例如 `ty::TraitRef<'tcx>`），但有些模块选择显式导入，一组较大或较小的名称。
