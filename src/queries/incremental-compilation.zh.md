# 增量编译

增量编译方案本质上是对整个查询系统的一个非常简单的扩展。我们首先描述一个稍微简化的真实事物的变体——“基本算法”，然后描述一些可能的改进。

## 基本算法

基本算法称为**红绿色**算法[萨尔萨^]. 高级的想法是，在每次运行编译器之后，我们将保存我们所做的所有查询的结果，以及**查询DAG**. 这个**查询DAG**是一个[达格]执行其他查询的查询的索引。因此，例如，如果计算q1需要计算q2，那么从查询q1到另一个查询q2会有一条边（注意，由于查询不能依赖于它们本身，所以这会导致DAG而不是通用图）。

[dag]: https://en.wikipedia.org/wiki/Directed_acyclic_graph

在编译器的下一次运行中，我们有时可以重用这些查询结果，以避免重新执行查询。我们通过分配每个查询**颜色**：

-   如果查询是彩色的**红色**，这意味着它在编译期间的结果**改变**从以前的编译。
-   如果查询是彩色的**绿色**这意味着它的结果是**相同的**作为以前的汇编。

这里有两个关键的见解：

-   首先，如果查询q的所有输入都是绿色的，那么查询q**必须**结果与上次的值相同，因此不需要重新执行（否则编译器不具有确定性）。
-   其次，即使查询的某些输入发生更改，也可能是**仍然**产生与先前编译相同的结果。特别是，查询只能使用其输入的一部分。
    -   因此，在执行查询之后，我们总是检查它是否产生与前一次相同的结果。**如果是这样，**我们仍然可以将查询标记为绿色，从而避免重新执行依赖查询。

### 尝试标记绿色算法

增量编译的核心是一种称为“Try-Mark Green”的算法。它的任务是确定给定查询q的颜色（必须尚未执行）。在Q有红色输入的情况下，确定Q的颜色可能需要重新执行Q以便我们可以比较它的输出，但是如果Q的所有输入都是绿色的，那么我们可以得出结论，Q必须是绿色的，而不需要重新执行或检查它的值。在编译器中，这允许我们避免在不需要时从磁盘反序列化结果，事实上，我们有时可以跳过*串行化*结果也是如此（请参见下面的“改进”部分）。

尝试按如下方式标记绿色作品：

-   首先检查查询q是否在上次编译期间执行。
    -   如果没有，我们可以正常地重新执行查询，并将其指定为红色。
-   如果是，则加载q的“依赖查询”。
-   如果有保存的结果，则加载`reads(Q)`来自查询DAG的向量。“reads”是Q在执行期间执行的一组查询。
    -   对于中的每个查询r`reads(Q)`，我们使用try-mark-green递归地要求r的颜色。
        -   注意：重要的是我们访问`reads(Q)`与原始编译中的顺序相同。见[下面关于查询DAG的部分](#dag).
        -   如果**任何**节点中的`reads(Q)`上色**红色**，则q是脏的。
            -   我们重新执行q并将其结果的散列与前一次编译的结果的散列进行比较。
            -   如果散列值没有更改，我们可以将q标记为**绿色**然后返回。
        -   否则，**全部的**节点中的`reads(Q)`必须是**绿色**. 在这种情况下，我们可以将Q着色为**绿色**然后返回。

<a name="dag"></a>

### 查询DAG

查询DAG代码存储在[`src/librustc/dep_graph`][dep_graph]. DAG的构造是通过检测查询执行来完成的。

一个关键点是查询DAG还跟踪排序；也就是说，对于每个查询Q，我们不仅跟踪Q读取的查询，还跟踪**秩序**在其中阅读。这允许Try Mark Green以相同的顺序返回这些查询。这一点很重要，因为一旦子查询恢复为红色，我们就不能再确定Q是否会像以前一样沿着相同的路径继续。也就是说，想象这样一个查询：

```rust,ignore
fn main_query(tcx) {
    if tcx.subquery1() {
        tcx.subquery2()
    } else {
        tcx.subquery3()
    }
}
```

现在想象一下，在第一次编辑时，`main_query`从执行开始`subquery1`，这将返回true。在这种情况下，下一个查询`main_query`执行将`subquery2`和`subquery3`不会被执行。

但是现在想象一下**下一个**编译时，输入已更改为`subquery1`收益率**假**. 在这种情况下，`subquery2`永远不会执行。如果尝试的话，马克·格林会去拜访`reads(main_query)`但是，它可能会出现故障`subquery2`之前`subquery1`然后执行。这可能会导致ICES和编译器中的其他问题。

[dep_graph]: https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph

## 基本算法的改进

在对基本算法的描述中，我们说在编译结束时，我们将保存执行的所有查询的结果。在实践中，这可能是非常浪费的——许多结果重新计算非常便宜，而序列化和反序列化并不是一个特别的胜利。实际上，我们要做的就是拯救**散列**在我们执行的所有子查询中。然后，在某些情况下，我们**也**保存结果。

这就是为什么增量算法将计算**颜色**对于通常不需要其值的节点，通过计算**结果**节点的计算结果是通过这样一个简单的算法完成的：

-   检查保存的Q结果是否可用。如果是，则计算q的颜色。如果q为绿色，则反序列化并返回保存的结果。
-   否则，执行q。
    -   然后，我们可以比较结果的散列值，如果结果没有改变，那么颜色Q将变为绿色。

## 资源

初始设计文件见[https://github.com/nikomastsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md](https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md)它扩展了记忆化细节，为这个系统提供了更高层次的概述和动力。

# 脚注

[萨尔萨^]：我很早就想将其重命名为salsa算法，但它从未流行过。-尼科马塔基斯
