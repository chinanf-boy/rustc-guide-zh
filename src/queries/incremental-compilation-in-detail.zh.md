# 详细的增量编译

增量编译方案，本质上是对整个查询系统来说，一个非常简单的扩展。它依赖于这样一个事实：

1.  查询是纯函数 —>— 给定相同的输入，查询将始终产生相同的结果，并且
2.  查询模型在无环图中，构造编译，使各个计算之间的依赖关系显式化。

本章将解释如何使用这些属性，使事情增量化，然后继续讨论版本实现问题。

# 增量查询执行的一种基本算法

如[查询执行模型入门][query-model]中所述，查询调用形成有向无环图。下面是上一章的例子：

```ignore
  list_of_all_hir_items <----------------------------- type_check_crate()
                                                               |
                                                               |
  Hir(foo) <--- type_of(foo) <--- type_check_item(foo) <-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
                    v                                          |
  Hir(bar) <--- type_of(bar) <--- type_check_item(bar) <-------+
```

由于从一个查询到另一个查询的每次访问，都必须经过查询上下文，所以我们可以记录这些访问，从而实际上，在内存中构建这个依赖关系图。在启用依赖项跟踪的情况下，当编译完成时，我们知道调用了哪些查询（图的节点）和每次调用时，有哪些查询或输入，用于计算查询结果（图的边）。

现在假设，我们更改程序的源代码，使`bar`看起来和以前不一样。我们的目标是在重新使用(所有其他查询的)缓存结果的同时，只重新计算那些实际受更改影响的查询。根据依赖关系图，我们可以做到这一点。对于一个给定的查询调用，图形会准确地告诉我们，计算其结果所用的数据是什么，我们只需要沿着边走，直到走到发生变化的地方。如果我们没有遇到任何变化，我们就知道查询的结果，仍然与缓存中的结果相同。

从上面，采取`type_of(foo)`调用作为示例，我们可以通过跟踪其输入的边，来检查缓存的结果是否仍然有效。唯一的边来到`Hir(foo)`这里，有个未受更改影响的输入。所以我们知道`type_of(foo)`的缓存结果仍然有效。

这个`type_check_item(foo)`的故事有点不同，我们再次沿边走，已经知道了`type_of(foo)`很好，然后我们到达`type_of(bar)`，这个还没有检查过，所以我们走过`type_of(bar)`，邂逅了`Hir(bar)`，它*有*改变。结论是，`type_of(bar)`产生的结果，可能会与缓存结果不同，并且传递性质，`type_check_item(foo)`的结果可能也改变了。因此，我们重新运行`type_check_item(foo)`，然后重新运行`type_of(bar)`，最终，返回一个最新的结果，因它读取的是最新版本的`Hir(bar)`。

# 基本算法的问题：误报

如果你仔细阅读上一段，你会发现，`type_of(bar)`*可能*已更改，因为其中一个输入已更改。还有一种可能性，即，它仍可能产生完全相同的结果，*尽管*它的输入已更改。下面，考虑一个简单查询的示例，该查询只计算整数的符号：

```ignore
  IntValue(x) <---- sign_of(x) <--- some_other_query(x)
```

让我们说`IntValue(x)`开始作为`1000`，然后设置为`2000`。尽管，`IntValue(x)`两种情况不同，但`sign_of(x)`会产生一样的结果`+`。

但是，如果我们遵循基本算法，`some_other_query(x)`必须（不必要地）重新计算，因为它依赖于已更改的输入。在这种情况下，变化检测，会产生“误报”，因为它必须保守地假设`some_other_query(x)`可能会受到输入变化的影响。

不幸的是，编译器中的实际查询中充满了这样的例子，对输入的微小更改，通常可能会影响输出二进制文件的很大一部分。因此，我们必须使变化检测系统更加智能和准确。

# 提高精度：红绿算法

通过，加入变化检测和查询重新执行，可以解决“误报”问题。当试图确定某个缓存结果，是否仍然有效时，我们可以检查结果*事实上*，是否在我们被迫重新执行后，发生了变化。

我们称此算法为红绿算法(不管怎样)，因为如果我们能够证明，节点的缓存结果仍然有效，则在依赖关系图中，分配为绿色，如果重新执行结果后发现结果不同，则将被分配为红色。

红绿变化的跟踪是在 try-mark-green 算法中实现的，我想你已经猜到，它试图将给定节点标记为绿色：

```rust,ignore
fn try_mark_green(tcx, current_node) -> bool {

    // 获取 inputs 到 `current_node`, i.e. 得到直接沿`node`边而来的节点
    let dependencies = tcx.dep_graph.get_dependencies_of(current_node);

    // 现在，检查所有输入的变化
    for dependency in dependencies {

        match tcx.dep_graph.get_node_color(dependency) {
            Green => {
                // 该输入已被检查，在它没有变化之前; 所以我们可以下一输入的检查
            }
            Red => {
                // 我们查到一个输入变化了. 我们不能标记
                // `current_node`为绿色， 要重新运行对应的查询。
                return false
            }
            Unknown => {
                // 第一次仔细看这些个节点. 让我们递归调用 try_mark_green() ，试试让其标记上绿色。
                if try_mark_green(tcx, dependency) {
                    // 我们成功把输入标记为绿色， 继续下一个
                } else {
                    // 我们 *无法* 标记 输入为绿色. 这意味着，我们
                    // 不知道其值是否变化了。 为了理解真相 find
                    // out, 现在我们需要重新运行相应的查询!
                    tcx.run_query_for(dependency);

                    // 再次获取与检查该节点的颜色. 聚焦运行中的查询，到底是红色 
                    // (如果查询结果与我们缓存的结果不同) 还是 绿色 (如果是同一结果)。
                    match tcx.dep_graph.get_node_color(dependency) {
                        Red => {
                            // 输入变为红色, 所以我们不能标记
                            //  `current_node` 为绿色.
                            return false
                        }
                        Green => {
                            // Re-running the query paid off! 结果与
                            // 之前的一样, 所以该输入不会使
                            // `current_node`无效。
                        }
                        Unknown => {
                            // 在重新运行该查询后，不可能该节点是没有颜色的！
                            panic!("unreachable")
                        }
                    }
                }
            }
        }
    }

    // 如果我们遍历了整个循环, 这意味着，我们所有的输入已经
    // 变为绿色. 如果所有输入都没有变化, 意思是
    // 查询结果对应当前`current_node`，不用变啦。
    tcx.dep_graph.mark_green(current_node);

    true
}

// Note: 实际实现，在
//       src/librustc/dep_graph/graph.rs
```

通过使用红绿色标记，我们可以避免在变化检测过程中，出现误报的破坏性累积效应。每当以增量模式执行查询时，我们首先检查它是否已经是绿色的。如果不是，我们就在上面运行`try_mark_green()`。如果之后，它仍然不是绿色的，那么我们实际调用查询 provider，重新计算结果。

# 现实世界：坚持是如何，让一切变得复杂的

上面的部分描述了增量编译的底层算法，但是由于编译器进程，会在完成后退出，并把带有结果缓存的查询上下文，置于遗忘状态，所以我们会将数据保存到磁盘，以便下一个编译会话可，以使用它。这带来了一系列全新的实现挑战：

- 查询结果缓存存储在磁盘上，因此它们不易用于变化比较。

<!-- HERE -->

- 随后的编译会话，将从新的更改代码版本开始。一个全局，顺序计数器生成的各种 ID 和索引（例如`NodeId`，`DefId`等等），可能发生了变化，使得磁盘上的保存结果不再立即可用，因为相同的数字 ID 和索引可能在新的编译会话中，引用了全新的内容。
- 将事物存储到磁盘是有代价的，所以在编译会话之间，不应该实际地缓存每一小块信息。固定大小的、普通的旧数据比，在（反）序列化期间，需要运行分支代码的复杂数据更受欢迎。

以下小节描述，当前编译器，如何解决这些问题。

## 稳定性问题：弥合编译会话之间的鸿沟

如前所述，各种 ID（如`DefId`）由编译器，以某种方式依赖于，正在编译的源代码内容生成。ID 分配通常具有确定性，也就是说，如果两次编译完全相同的代码，将以相同的 ID 结束。但是，如果有什么变化，例如在文件中间添加了一个函数，就不能保证任何东西，都具有与以前相同的 ID。

因此，我们不能像在内存中表示数据，那样表示磁盘缓存中的数据。例如，如果我们只是存储一段类型信息，比如`TyKind::FnDef(DefId, &'tcx Substs<'tcx>)`（正如我们在内存中所做的），然后`DefId`在新的编译会话中，若指向一个不同的函数，那我们就麻烦啦。

解决这个问题的方法是帮 ID 找到“稳定”表，这些表单会在编译会话之间保持 ID 的有效性。对最关键的情况，`DefId`S，这些是所谓的`DefPath`，每一个`DefId`有一个对应的`DefPath`，但配上一个数字标识，一个`DefPath`是基于路径去辨识项，例如`std::collections::HashMap`。 这种 ID 的优点是它不受无关更改的影响。例如，可以把新函数添加到`std::collections`，但`std::collections::HashMap`，仍然是`std::collections::HashMap`。 一 `DefPath`在对进行源代码更改来说，是“稳定的”，而`DefId`不是。

还有`DefPathHash`，它只是一个 128 位哈希值的`DefPath`. 两者包含相同的信息，我们主要使用`DefPathHash`，因为处理起来更简单，能`Copy`，且是自带的。

稳定标识符的这一原则，让磁盘缓存中的数据，在更改源代码方面上，具备弹性。不是存储`DefId`，而是存储`DefPathHash`。当我们从缓存反序列化某些内容时，我们会将`DefPathHash`，映射到*当前*编译会话的相应`DefId`（这只是一个简单的哈希表查找）。

有个`HirId`，用于辨识 HIR 组件(没有自己的`DefId`)，是另一个同等稳定的 ID。（理论上）一对`DefPath`和`LocalId`，这里的`LocalId`在其"owner"（例如`hir::Item`）内，表示某本地物（例如`hir::Expr`）如果所有权被移动，则`LocalId`里面的，仍然是一样的。

## 检查查询结果是否有更改：StableHash 和 Fingerprints

为了进行 red-green-marking，我们经常需要检查查询结果，与前一个编译会话中的结果相比，是否发生了更改。不过，这有两个性能问题：

- 我们希望避免为了进行比较而，从磁盘加载上一结果。我们已经计算了新的结果，后面会用到。同样，从磁盘加载结果也会“污染”那些不太可能被使用的中间数据。
- 我们不希望将每个结果存储在磁盘缓存中。例如，把已经在上游箱子中使用的东西，保存到磁盘上会浪费精力。

编译器通过使用所谓的`Fingerprint`(指纹)，来避免这些问题。每次计算新的查询结果时，查询引擎将计算结果变为一个 128 位的哈希值。我们称这个哈希值为该查询结果的`Fingerprint`。哈希是（必须）以“稳定的方式”完成的。这意味着，某些哈希内容在编译会话之间，可能会发生变化（例如一个`DefId`)，那我们拿它的稳定值（例如，相应的`DefPath`）来哈希。这就是`StableHash`基础设施所做的全部。用这种`Fingerprint`方式所计算的东东，在两个不同的编译会话中，仍然可以比较。

下一步是将这些指纹与依赖关系图一起存储。这很便宜，因为指纹只是要复制的字节。将整个指纹集与依赖关系图一起加载也很便宜。

现在，当 red-green-marking 到达，需要检查其结果是否发生更改的点时，它可以将（已加载的）以前的指纹与新结果的指纹进行比较。

这种方法相当有效，但并非没有缺陷：

- 哈希冲突的可能性很小。也就是说，两个不同的结果会具有相同的指纹，即便这个概率很微小，系统会错误地假设结果没有更改，从而导致错过更新。

  我们通过使用高质量的哈希函数和 128 位宽的哈希值来降低这种风险。由于这些措施，哈希冲突的实际风险可以忽略不计。

- 计算指纹是相当昂贵的。这是增量编译比非增量编译慢的主要原因。我们被迫使用一个好的、却也昂贵的哈希函数，并且在进行哈希时，我们必须将事物映射到它们的稳定等价物。

在未来，我们可能希望，这个问题不同的解决方法。但现在它是`StableHash`和`Fingerprint`.

## 两个 DepGraphs 的故事：新旧

依赖跟踪的初始描述掩盖了一些细节，这些细节在实际尝试实现时，很快就感到头痛。特别是，正在处理*两个*依赖关系图，我们很容易忽视掉：在前一个编译会话中构建的，以及为当前编译会话构建的。

当编译会话开始时，编译器将前一个依赖关系图，作为不可变的数据块加载到内存中。然后，当调用一个查询时，它首先尝试将图中的相应节点标记为绿色。这实际上，意味着我们正在尝试，若当前会话的查询键，对应*前一个* dep-graph 中绿色节点的查询键，我们会标上了绿色。如何对当前查询键和上一个`DepNode`两者，进行映射？答案再一次是`Fingerprint`：依赖关系图中的节点由一个查询键的指纹标识。由于指纹在编译会话中是稳定的，因此计算当前会话中的指纹，可以让我们在上一个会话的依赖关系图中找到一个节点。如果我们找不到具有给定指纹的节点，这意味着查询键，引用了前一个会话中尚未存在的内容。

因此，在上一个依赖关系图中找到 dep-node 后，我们可以查找它的依赖关系（也可以查找上一个图中的 dep-node ），然后继续使用 Try-Mark-Green 算法的其余部分。下一个有趣的事情发生在我们成功地将节点标记为绿色时。在这一点上，我们将节点和边复制到它的依赖关系图中，从旧图复制到新图中。我们必须这样做，因为新的 dep-graph 不能通过常规的依赖跟踪获取节点和边。跟踪系统只能在实际运行查询时，记录边 —— 尽管我们已经缓存了结果，但(重)运行查询，正是我们想要避免的。

编译会话完成后，所有未更改的部分，都已从旧的复制到新的依赖关系图中，而更改的部分已由跟踪系统添加到新的关系图中。此时，新的图将与查询结果缓存，一起序列化到磁盘，并可以在随后的编译会话中，充当前一个 dep-graph。

## 你忘了什么吗？：缓存升级

TODO

# 未来：当前系统的缺陷和可能的解决方案

TODO

[query-model]: ./query-evaluation-model-in-detail.zh.html
