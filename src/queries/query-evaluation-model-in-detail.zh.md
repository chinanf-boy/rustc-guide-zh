# 详细的查询评估模型

本章提供了对抽象模型查询的深入研究。它不涉及实现细节，而是试图解释底层逻辑。因此，这里的示例已经被简化，并没有直接反映编译器的内部API。

## 什么是查询？

抽象地说，我们把编译器对给定板条箱的知识视为一个“数据库”，而查询是询问编译器关于它的问题的方式，也就是说，我们“查询”编译器的“数据库”以了解事实。

但是，这个编译器数据库有一些特殊之处：它以空开始，在执行查询时按需填充。因此，如果数据库尚未包含查询结果，则查询必须知道如何计算其结果。为此，它可以访问其他查询和数据库在创建时预先填充的某些输入值。

因此，查询由以下内容组成：

-   标识查询的名称
-   指定要查找的内容的“键”
-   指定生成哪种结果的结果类型
-   一个“provider”，它是一个函数，指定如果数据库中没有结果，如何计算结果。

例如，`type_of`查询是`type_of`，其查询键是`DefId`识别我们想要知道的项目类型，结果类型是`Ty<'tcx>`提供程序是一个函数，给定查询键和对数据库其余部分的访问权限，可以计算该键标识的项的类型。

所以在某种意义上，查询只是一个将查询键映射到相应结果的函数。但是，我们必须应用一些限制，以使其合理：

-   键和结果必须是不可变的值。
-   提供程序函数必须是纯函数，也就是说，对于同一个键，它必须始终产生相同的结果。
-   提供程序函数所采用的唯一参数是键和对“查询上下文”的引用（它提供对“数据库”其余部分的访问）。

通过调用查询，可以轻松地建立数据库。查询提供程序将调用其他查询，这些查询的结果已被缓存或通过调用其他查询提供程序计算出来。这些查询提供程序调用在概念上形成了一个有向非循环图（DAG），其左侧是在创建查询上下文时已经知道的输入值。

## 缓存/记忆

查询调用的结果是“memoized”，这意味着查询上下文将结果缓存在内部表中，当再次使用相同的查询键调用查询时，将从缓存返回结果，而不是再次运行提供程序。

这种缓存对于提高查询引擎的效率至关重要。如果没有记忆化，系统仍然是健全的（也就是说，它将产生相同的结果），但相同的计算将反复进行。

memoization是查询提供者必须是纯函数的主要原因之一。如果调用一个提供程序函数可以为每次调用产生不同的结果（因为它访问一些全局可变状态），那么我们就不能将结果memoize。

## 输入数据

创建查询上下文时，它仍然为空：未执行任何查询，未缓存任何结果。但是上下文已经提供了对“输入”数据的访问，即在创建上下文之前计算的不可变数据块，并且查询可以访问这些数据来进行计算。目前，这个输入数据主要由HIR映射和编译器调用时使用的命令行选项组成。将来，输入将只包含命令行选项和源文件列表——HIR映射本身将由处理这些源文件的查询提供。

如果没有输入，查询将处于无效状态，没有任何计算结果的内容（请记住，查询提供程序只能访问其他查询和上下文，而不能访问任何其他外部状态或信息）。

对于查询提供程序，输入数据和其他查询的结果看起来完全相同：它只告诉上下文“给我x的值”。因为输入数据是不可变的，所以提供程序可以依赖于它在不同的查询调用中是相同的，就像查询结果一样。

## 一些查询的执行跟踪示例

这个DAG查询调用是如何产生的？在某种程度上，编译器驱动程序将创建查询上下文（目前还为空）。然后，它将从查询系统外部调用执行其任务所需的查询。如下所示：

```rust,ignore
fn compile_crate() {}
    let cli_options = ...;
    let hir_map = ...;

    // Create the query context `tcx`
    let tcx = TyCtxt::new(cli_options, hir_map);

    // Do type checking by invoking the type check query
    tcx.type_check_crate();
}
```

这个`type_check_crate`查询提供程序如下所示：

```rust,ignore
fn type_check_crate_provider(tcx, _key: ()) {
    let list_of_items = tcx.hir_map.list_of_items();

    for item_def_id in list_of_hir_items {
        tcx.type_check_item(item_def_id);
    }
}
```

我们看到了`type_check_crate`查询访问输入数据（`tcx.hir_map.list_of_items()`）并调用其他查询（`type_check_item`）。《`type_check_item`将自己invocations接入输入数据和/或调用其他的查询，所以，在一天比invocations学院查询将从backwards内置IP节点：这是initially executed

```ignore
         (2)                                                 (1)
  list_of_all_hir_items <----------------------------- type_check_crate()
                                                               |
    (5)             (4)                  (3)                   |
  Hir(foo) <--- type_of(foo) <--- type_check_item(foo) <-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
    (7)             v  (6)                  (8)                |
  Hir(bar) <--- type_of(bar) <--- type_check_item(bar) <-------+

// (x) denotes invocation order
```

我们也看不见一个查询结果，往往可以从缓存中读：`type_of(bar)`我对计算机`type_check_item(foo)`所以当`type_check_item(bar)`需要它，它已经在高速缓存。

在cached查询结果的查询上下文的上下文的AA AA大的生活。所以如果编译驱动invoked之后对另一个查询，将以上图的静态和executed已存在的查询将不需要再做两个。

## 周期

除非我们之前的那一天invocations查询。然而，这将是很容易形成一个循环图，例如，有一个像下面的查询模式：

```rust,ignore
fn cyclic_query_provider(tcx, key) -> u32 {
  // Invoke the same query with the same key again
  tcx.cyclic_query(key)
}
```

由于查询提供者是正则函数，这会增加多表现为：评价会粘在一个无限递归。一个查询，这样会不会是非常有用的或。然而，有时候脸部某些用户输入无效的结果的查询可以被称为在一个循环的方式。“查询引擎包括一个检查invocations和循环周期，因为是个irrecoverable误差，将堕胎和一个“执行周期误差信息的tries”这两个人读。

在某些点的编译器有一个观念：“周期率”，这是一个可以“清除”如果execute a查询IP网络端的周期性，在一些其他的proceed服装。然而，这是后来删除，因为它是不明确的说，这是理论的影响，尤其是对增量编译。

## “窃取”查询

有些查询的结果包装在`Steal<T>`结构。这些查询的行为与常规查询完全相同，但有一个例外：它们的结果在某个时刻可能会被“窃取”出缓存，这意味着程序的其他部分将拥有它的所有权，并且无法再访问结果。

这种窃取机制纯粹是作为性能优化而存在的，因为有些结果值的克隆成本太高（例如函数的mir）。似乎结果窃取会违反查询结果必须是不可变的条件（毕竟我们正在将结果值移出缓存），但只要突变不可见，就可以了。这是通过两件事实现的：

-   在结果被窃取之前，我们确保急切地运行可能需要读取该结果的所有查询。这必须通过调用这些查询手动完成。
-   每当一个查询试图访问一个被盗的结果时，我们会使编译器结冰，这样一个条件就不会被忽视。

这不是一个理想的设置，因为需要手动干预，所以应该谨慎使用它，并且只有当众所周知哪些查询可以访问给定的结果时才使用它。然而，在实践中，偷窃并不是一个很大的维护负担。

总而言之：“窃取查询”以可控的方式破坏了一些规则。有检查的地方，以确保没有任何事情可以悄悄地出错。

## 并行查询执行

查询模型具有一些特性，使得并行评估多个查询实际上是可行的，而无需付出太多的努力：

-   查询提供者可以访问的所有数据都是通过查询上下文访问的，因此查询上下文可以负责同步访问。
-   查询结果必须是不可变的，这样不同的线程就可以同时安全地使用它们。

夜间编译器已经实现了如下并行查询评估：

当查询时`foo`的缓存表`foo`被锁定。

-   如果已经有了结果，我们可以克隆它，释放锁，然后就完成了。
-   如果没有缓存条目，也没有其他活动查询调用计算相同的结果，那么我们将该键标记为“正在进行”，释放锁并开始计算。
-   如果有*是*对同一个键的另一个查询调用正在进行中，我们释放锁，然后阻塞线程，直到另一个调用计算出我们等待的结果为止。这不能死锁，因为正如前面提到的，查询调用形成一个DAG。某些线程将始终取得进展。
