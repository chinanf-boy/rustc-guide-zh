# 发出诊断

已经付出了很多努力`rustc`有很好的错误消息。本章介绍如何从编译器中发出编译错误和lints。

## `Span`

[`Span`][span]是主要的数据结构`rustc`用于表示正在编译的代码中的位置。`Span`s附加到HIR和MIR中的大多数构造，允许更多信息性的错误报告。

[span]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.Span.html

一个`Span`可以查找一个[`SourceMap`][sourcemap]获得一个“片段”用于显示错误[`span_to_snippet`][sptosnip]和其他类似的方法`SourceMap`。

[sourcemap]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceMap.html

[sptosnip]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceMap.html#method.span_to_snippet

## 错误消息

该[`rustc_errors`][errors]crate定义了用于报告错误的大多数实用程序。

[errors]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/index.html

[`Session`][session]和[`ParseSess`][parsesses]拥有允许报告错误的方法（或带有方法的字段）。这些方法通常有类似的名称`span_err`要么`struct_span_err`要么`span_warn`等等......有很多;它们会发出不同类型的“错误”，例如警告，错误，致命错误，建议等。

[parsesses]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html

[session]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html

通常，有两类这样的方法：直接发出错误的方法和允许更好地控制发射内容的方法。例如，[`span_err`][spanerr]在给定的情况下发出给定的错误消息`Span`但是[`struct_span_err`][strspanerr]而是返回一个[`DiagnosticBuilder`][diagbuild]。

`DiagnosticBuilder`允许您在发出错误之前向错误添加相关注释和建议，方法是调用[`emit`][emit]方法。（没有发射或[取消][cancel]一个`DiagnosticBuilder`将导致ICE。）见[文档][diagbuild]有关您可以做什么的更多信息。

[spanerr]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.span_err

[strspanerr]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.struct_span_err

[diagbuild]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html

[emit]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html#method.emit

[cancel]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.Diagnostic.html#method.cancel

```rust,ignore
// Get a DiagnosticBuilder. This does _not_ emit an error yet.
let mut err = sess.struct_span_err(sp, "oh no! this is an error!");

// In some cases, you might need to check if `sp` is generated by a macro to
// avoid printing weird errors about macro-generated code.

if let Ok(snippet) = sess.source_map().span_to_snippet(sp) {
    // Use the snippet to generate a suggested fix
    err.span_suggestion(suggestion_sp, "try using a qux here", format!("qux {}", snip));
} else {
    // If we weren't able to generate a snippet, then emit a "help" message
    // instead of a concrete "suggestion". In practice this is unlikely to be
    // reached.
    err.span_help(suggestion_sp, "you could use a qux here instead");
}

// emit the error
err.emit();
```

## 建议

除了准确地告诉用户*为什么*他们的代码是错误的，通常还可以告诉他们如何修复它。为此，`DiagnosticBuilder`提供了一个结构化的建议API，它可以在终端中令人愉悦地格式化代码建议，或者（在...时）`--error-format json`flag被传递为JSON供工具使用，最值得注意的是[Rust语言服务器][rls]和[`rustfix`][rustfix]。

[rls]: https://github.com/rust-lang/rls

[rustfix]: https://github.com/rust-lang-nursery/rustfix

并非所有建议都应该机械地应用。使用[`span_suggestion`][span_suggestion]的方法`DiagnosticBuilder`提出建议。最后一个参数提供了工具的提示，无论该建议是否机械适用。

[span_suggestion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html#method.span_suggestion

例如，要使我们的`qux`建议机器适用，我们会这样做：

```rust,ignore
let mut err = sess.struct_span_err(sp, "oh no! this is an error!");

if let Ok(snippet) = sess.source_map().span_to_snippet(sp) {
    err.span_suggestion(
        suggestion_sp,
        "try using a qux here",
        format!("qux {}", snip),
        Applicability::MachineApplicable,
    );
} else {
    err.span_help(suggestion_sp, "you could use a qux here instead");
}

err.emit();
```

这可能会发出错误

```console
$ rustc mycode.rs
error[E0999]: oh no! this is an error!
 --> mycode.rs:3:5
  |
3 |     sad()
  |     ^ help: try using a qux here: `qux sad()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
```

在某些情况下，例如当建议跨越多行或有多个建议时，建议会自行显示：

```console
error[E0999]: oh no! this is an error!
 --> mycode.rs:3:5
  |
3 |     sad()
  |     ^
help: try using a qux here:
  |
3 |     qux sad()
  |     ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
```

可能的值[`Applicability`][appl]是：

-   `MachineApplicable`：可以机械应用。
-   `HasPlaceholders`：无法机械应用，因为它在建议中有占位符文本。例如，“尝试添加类型：\`让x：\\ \<type>\`”。
-   `MaybeIncorrect`：不能机械地应用，因为建议可能是也可能不是好的。
-   `Unspecified`：不能机械地应用，因为我们不知道它属于上述哪种情况。

[appl]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html

## 皮棉

编译器的linting基础结构在[`rustc::lint`][rlint]模块。

[rlint]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/index.html

### 宣告皮棉

内置编译器lints在[`rustc_lint`][builtin]机箱。

[builtin]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html

每个线头定义为`struct`实现了`LintPass` `trait`. 特性实现允许您检查特定的语法结构，linter将遍历源代码。然后您可以选择以非常类似的方式发出lints来编译错误。最后，通过使用`declare_lint!`宏。

例如，下面的lint检查`while true { ... }`并建议使用`loop { ... }`相反。

```rust,ignore
// Declare a lint called `WHILE_TRUE`
declare_lint! {
    WHILE_TRUE,

    // warn-by-default
    Warn,

    // This string is the lint description
    "suggest using `loop { }` instead of `while true { }`"
}

// Define a struct and `impl LintPass` for it.
#[derive(Copy, Clone)]
pub struct WhileTrue;

impl LintPass for WhileTrue {
    fn get_lints(&self) -> LintArray {
        lint_array!(WHILE_TRUE)
    }
}

// LateLintPass has lots of methods. We only override the definition of
// `check_expr` for this lint because that's all we need, but you could
// override other methods for your own lint. See the rustc docs for a full
// list of methods.
impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {
    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {
        if let hir::ExprWhile(ref cond, ..) = e.node {
            if let hir::ExprLit(ref lit) = cond.node {
                if let ast::LitKind::Bool(true) = lit.node {
                    if lit.span.ctxt() == SyntaxContext::empty() {
                        let msg = "denote infinite loops with `loop { ... }`";
                        let condition_span = cx.tcx.sess.source_map().def_span(e.span);
                        let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);
                        err.span_suggestion_short(condition_span, "use `loop`", "loop".to_owned());
                        err.emit();
                    }
                }
            }
        }
    }
}
```

### 编辑门控线头

有时我们想在新版本中改变一个线头的行为。为此，我们只需将转换添加到调用`declare_lint!`：

```rust,ignore
declare_lint! {
    pub ANONYMOUS_PARAMETERS,
    Allow,
    "detects anonymous parameters",
    Edition::Edition2018 => Warn,
}
```

这使得`ANONYMOUS_PARAMETERS`lint在2015版中默认允许，但在2018版中默认警告。

下一版本中表示不兼容（即错误）的线头也应注册为`FutureIncompatibilityLint`S在[`register_builtins`][rbuiltins]功能在[`rustc_lint::lib`][builtin].

### 皮棉组

可以分组打开线头。这些组在[`register_builtins`][rbuiltins]功能在[`rustc_lint::lib`][builtin]. 这个`add_lint_group!`宏用于声明新组。

[rbuiltins]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html

例如，

```rust,ignore
    add_lint_group!(sess,
                    "nonstandard_style",
                    NON_CAMEL_CASE_TYPES,
                    NON_SNAKE_CASE,
                    NON_UPPER_CASE_GLOBALS);
```

这定义了`nonstandard_style`打开列出的线头的组。用户可以使用`!#[warn(nonstandard_style)]`源代码中的属性，或通过传递`-W nonstandard-style`在命令行上。

### 在编译器的早期运行

有时，您可能需要定义一个在初始化linting系统之前运行的lint（例如，在解析或宏扩展期间）。这是有问题的，因为我们需要计算lint级别来知道是否应该发出警告、错误或者什么都不发出。

为了解决这个问题，我们对棉绒进行缓冲，直到处理完棉绒系统。[`Session`][sessbl]和[`ParseSess`][parsebl]都有`buffer_lint`方法来缓冲lint，以备以后使用。棉绒系统稍后会自动处理缓冲的棉绒。

[sessbl]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.buffer_lint

[parsebl]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html#method.buffer_lint

因此，要定义在编译早期运行的lint，可以像normal一样定义lint，但使用`buffer_lint`.

#### 甚至在编译器的早期

语法分析器（解析器）`libsyntax`）有趣的是，它不能依赖于任何其他`librustc*`箱子特别是，它不能依赖于`librustc::lint`或`librustc_lint`，其中定义了所有编译器linting基础结构。太麻烦了！

为了解决这个问题，`libsyntax`定义自己的缓冲lint类型，其中`ParseSess::buffer_lint`使用。在宏扩展之后，这些缓冲的线头将被转储到`Session::buffered_lints`由编译器的其余部分使用。

缓冲棉的使用`libsyntax`与编译器的其余部分几乎相同，只有一个例外，因为我们无法导入`LintId`S代表我们想要散发的绒毛。相反，[`BufferedEarlyLintId`]使用类型。如果要定义一个新的lint，则需要向该枚举添加一个条目。然后，将适当的映射添加到[`Lint::from_parser_lint_id`][fplid].

[`bufferedearlylintid`]: https://doc.rust-lang.org/nightly/nightly-rustc/syntax/early_buffered_lints/enum.BufferedEarlyLintId.html

[fplid]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/struct.Lint.html#method.from_parser_lint_id
